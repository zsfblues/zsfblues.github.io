<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="zsfblues"><meta name="renderer" content="webkit"><meta name="copyright" content="zsfblues"><meta name="keywords" content="zsfblues' blog"><meta name="description" content="IT,互联网"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>浅谈Redis中的内存优化设计 · zsfblues' blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/me.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><meta name="generator" content="Hexo 4.2.0"></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/me.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">zsfblues</div><div class="profile-signature">zsfblues' blog</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">zsfblues' blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">浅谈Redis中的内存优化设计</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2020/05/08</span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="Redis"> Redis</a></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><p>Redis作为一个高效的kv型键值型数据库，除了依赖内存高效处理读写操作外，在节约内存的设计上也有着近乎于苛刻，总是想尽一切办法来节约内存，本次主要结合两个比较典型的数据结构上的设计来一窥Redis中的内存优化之道：sds和ziplist。</p>
<hr>
<p>在介绍这两个数据结构之前，我们先聊一下基础数据结构：robj。</p>
<p>从Redis的使用者的角度来看，一个Redis节点包含多个db（非cluster模式下默认是16个，cluster模式下只能是1个），而一个db就是维护了从key 到value的映射关系。key只能是string类型，而value可以是多种数据类型，比如：string，list，hash，zset，set等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* 已废弃 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* 已废弃 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>type：value的类型字段，占用4bit(总计表达16种)，目前就有以下几种</p>
<ul>
<li><pre><code class="c"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STRING 0    <span class="comment">/* String object. */</span></span>
<span class="meta">#<span class="meta-keyword">define</span> OBJ_LIST 1      <span class="comment">/* List object. */</span></span>
<span class="meta">#<span class="meta-keyword">define</span> OBJ_SET 2       <span class="comment">/* Set object. */</span></span>
<span class="meta">#<span class="meta-keyword">define</span> OBJ_ZSET 3      <span class="comment">/* Sorted set object. */</span></span>
<span class="meta">#<span class="meta-keyword">define</span> OBJ_HASH 4      <span class="comment">/* Hash object. */</span></span>
<span class="meta">#<span class="meta-keyword">define</span> OBJ_MODULE 5    <span class="comment">/* Module object. Redis4.0引进了可插拔的模块来扩展功能，这种类型的对象标明是由模块直接管理*/</span></span>
<span class="meta">#<span class="meta-keyword">define</span> OBJ_STREAM 6    <span class="comment">/* Stream object. */</span></span>
&lt;!--￼<span class="number">1</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<p>其中除了SDS_TYPE_5这种类型没有alloc和len字段外，其它类型都会包含，而对于SDS_TYPE_5这种类型，主要用于存储不超过32字节的字符串(5bit最大值)，在最低的3bit上用于存储flags类型信息，高5bit用户存储字符长度，不过在具体的使用上，由于这种类型扩展性不好，并不会使用这种类型进行存储，但判定字符串大于小于32字节时会自动转换为SDS_TYPE_8类型。</p>
<p>sds的类型结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; </span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; </span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;</span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; </span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; </span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len;</span><br><span class="line">    <span class="keyword">uint32_t</span> alloc;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; </span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; </span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; </span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>len：表示当前存储字符串已消耗的字节大小</p>
<p>alloc：总共分配的内存大小(不包含header大小以及NULL结束符所占用的大小)</p>
<p>flags：sds的类型信息，用低3bit标识</p>
<p><strong>__attribute__((__packed__))</strong>这个在C语言中是为了让编译器以紧凑模式来分配内存，默认情况下编译器可能会为struct的字段做优化对齐，在其中填充空字节。这样一来在内存分配上就不会连续，后续会看到Redis在获取sds的flags字段信息时是通过header的大小向低位偏移一个字节获取的。</p>
<p>在robj为string类型时总共有三种不同encoding，其中OBJ_ENCODING_RAW和OBJ_ENCODING_EMBSTR都是由sds来表示，在object.c的文件中有一个用于创建EMBSTR类型的对象方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createEmbeddedStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(robj)+<span class="keyword">sizeof</span>(struct sdshdr8)+len+<span class="number">1</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr8</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">o</span>+1);</span> <span class="comment">//内存连续，所以这里的1要理解为sizeof(robj)，即指针指向sdshdr</span></span><br><span class="line"></span><br><span class="line">    o-&gt;type = OBJ_STRING;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_EMBSTR;</span><br><span class="line">    o-&gt;ptr = sh+<span class="number">1</span>; <span class="comment">// sh+1 实际上是 sh + sizeof(struct sdshdr8)，指向buf</span></span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | LFU_INIT_VAL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o-&gt;lru = LRU_CLOCK();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    sh-&gt;alloc = len;</span><br><span class="line">    sh-&gt;flags = SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">if</span> (ptr == SDS_NOINIT)</span><br><span class="line">        sh-&gt;buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf,ptr,len);</span><br><span class="line">        sh-&gt;buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sh-&gt;buf,<span class="number">0</span>,len+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将robj和sds放在一个连续的内存块中分配，这样对于短字符串的存储有利于减少内存碎片，由以下部分组成</p>
<ul>
<li>16个字节的robj结构</li>
</ul>
<ul>
<li>3个字节的sdshdr8头</li>
<li>最多44个字节的sds字符数组</li>
<li>1个NULL结束符</li>
</ul>
<p>16 + 3 + 44 + 1=64，正好符合一些内存分配器(例如jemalloc)一次性能分配的最大连续内存大小，因而在设计上符合</p>
<p><img src="https://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/robj_embstr.png?x-oss-process=style/zsfimage" alt=""></p>
<h4 id="设计上的缺点"><a href="#设计上的缺点" class="headerlink" title="设计上的缺点"></a>设计上的缺点</h4><p>SDS虽然支持原生C字符串并且支持动态扩容，但仍有以下两个主要缺点</p>
<ol>
<li>很多操作(向字符串追加)需要创建新的SDS对象，这会导致更大的内存分配</li>
<li>由于SDS支持对象共享，意味着修改字符串时需要顾及所有引用他的地方</li>
</ol>
<h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><p>ziplist在官方上定义为一个拥有特殊编码的内存紧凑型双向列表。</p>
<p>ziplist在设计上节省内存的表现：</p>
<ol>
<li><p>双端list，为了向前遍历节点，不使用指针链接的方式(避免内存碎片导致内存浪费)，在内存分配上物理相邻，在每一个节点(entry)直接记录上一个节点的长度(prevrawlen),同步通过prevrawlensize标明上一个的节点编码大小，相比较于传统的指针遍历的方式，节省了指针占用内存较高的问题(依赖于系统版本，在64位系统上需要8个字节)</p>
</li>
<li><p>zlentry中encoding字段的存储设计，从大的方面说，encoding字段代表两种编码类型(int和string)，从小的方面看，在两大类型基础上，又将string分为(1,2,5bytes)三种小类型，int分为(1,2,3,4,8bytes)五种小类型</p>
</li>
</ol>
<blockquote>
<p><zlbytes> <zltail> <zllen> <entry> <entry> … <entry> <zlend></p>
</blockquote>
<p>zlbytes：占用4个字节，用于标识ziplist占用的总内存大小</p>
<p>zltail：占用4个字节标识最后一个entry的内存偏移量，方便进行类似pop之类需要在尾部执行的操作</p>
<p>zllen：占用2个字节，标识ziplist拥有entry个数</p>
<p>zlend：占用1个字节，ziplist的结束标识，使用固定值255</p>
<p>因此一个空的压缩列表由总字节长度(4字节)，尾节点偏移量(4字节)，节点数量(2字节)，以及值为255的特殊结束符(1字节)组成。</p>
<p>重点是要谈一谈entry的设计：</p>
<blockquote>
<p><prevlen> <encoding> <entry-data></p>
</blockquote>
<p>prevlen：用来存储前一个entry的长度，这样可以通过减去这个值快速从后向前进行遍历</p>
<p>encoding：当前entry的编码方式，包含字符串(3种)和数字类型(5种)</p>
<p>entry-data：保存entry的内容，在encoding为数字型时存在一种情况会被省略</p>
<hr>
<h4 id="字符串类型设计"><a href="#字符串类型设计" class="headerlink" title="字符串类型设计"></a>字符串类型设计</h4><table>
<thead>
<tr>
<th>encoding格式</th>
<th>占用长度</th>
<th>存储范围</th>
</tr>
</thead>
<tbody><tr>
<td>00xxxxxx</td>
<td>1字节</td>
<td>&lt;=63字节(6bit)</td>
</tr>
<tr>
<td>01xxxxxx|aaaaaaaa|</td>
<td>2个字节</td>
<td>&lt;=16383个字节(14bit)</td>
</tr>
<tr>
<td>10000000|aaaaaaaa|bbbbbbbb|cccccccc|dddddddd|</td>
<td>5个字节</td>
<td>&lt;=4294967295个字节(32bit)</td>
</tr>
</tbody></table>
<h4 id="数字类型设计"><a href="#数字类型设计" class="headerlink" title="数字类型设计"></a>数字类型设计</h4><table>
<thead>
<tr>
<th>encoding格式</th>
<th>占用长度</th>
<th>存储范围</th>
</tr>
</thead>
<tbody><tr>
<td>11111110(0xFE)</td>
<td>1个字节</td>
<td>-128-127的整数存储</td>
</tr>
<tr>
<td>11000000(0xc0 | 0&lt;&lt;4)</td>
<td>1个字节</td>
<td>16bit存储(-2^15^ - (2^15^ -1))</td>
</tr>
<tr>
<td>11110000(0xc0 | 3&lt;&lt;4)</td>
<td>1个字节</td>
<td>24bit存储(-2^23^ - (2^23^ -1))</td>
</tr>
<tr>
<td>11010000(0xc0 | 1&lt;&lt;4)</td>
<td>1个字节</td>
<td>32bit存储(-2^31^ - (2^31^ -1))</td>
</tr>
<tr>
<td>11100000(0xc0 | 2&lt;&lt;4)</td>
<td>1个字节</td>
<td>64bit存储(-2^63^ - (2^63^ -1))</td>
</tr>
<tr>
<td>11110001 - 1111101</td>
<td>1个字节</td>
<td>表示0 -12的整数</td>
</tr>
</tbody></table>
<p>其中最后一种情况是整数型存储的一种特殊情况，在这类型中，entry-data的部分会被省略，和encoding字段合二为一。</p>
<p>接下来以一个具体事例来讲解ziplist存储情况:</p>
<img src="https://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/ziplist_exp.png" style="zoom70%;" />

<p>从这个例子中：</p>
<ol>
<li>entry1是一个字符串编码的节点类型，由于是第一个entry，所以prerawlen是0，占用1byte，内容是”xuanlin”共7个字符，占用7bytes，将ASCII码转成16进制就为encoding-data的内容，由于在63bytes以内，所以类型为ZIP_STR_06B(00xxxxxx)</li>
<li>entry2是一个整数类型编码的节点类型，由于前一个entry总共占用9(1+1+7)个bytes，所以prerawlen是9，占用1byte，内容是”10”，介于0-12之间，所以为11111011，占用1byte，总共占用2bytes</li>
</ol>
<p>因此ziplist的整体长度就是4+4+2+9+2+1=22个字节，按照大端字节序存储就是0x16(<a href="https://www.ruanyifeng.com/blog/2016/11/byte-order.html" target="_blank" rel="noopener">关于字节序的类型说明</a> )，ztail就是(22-3=19)为0x13，</p>
<p>接下来以插入代码来讲解一下ziplist的工作流程(省略了一下内存拷贝的操作，无关主流程)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Insert item at "p". */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistInsert(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, prevlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">123456789</span>; </span><br><span class="line">    zlentry tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取前一个节点的长度 */</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            prevlen = zipRawEntryLength(ptail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 尝试将待插入节点按照数字编码 */</span></span><br><span class="line">    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class="line">        <span class="comment">/* 获取存储数字的大小 */</span></span><br><span class="line">        reqlen = zipIntSize(encoding);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 失败则按字符串编码，以字符串长度获取存储大小*/</span></span><br><span class="line">        reqlen = slen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 计算待插入节点的prerawsize大小 */</span></span><br><span class="line">    reqlen += zipStorePrevEntryLength(<span class="literal">NULL</span>,prevlen);</span><br><span class="line">    <span class="comment">/* 计算待插入节点的lensize */</span></span><br><span class="line">    reqlen += zipStoreEntryEncoding(<span class="literal">NULL</span>,encoding,slen);</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">/* 计算待插入节点与原节点的字节差 */</span></span><br><span class="line">    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 因为插入节点采用的copyOnWrite的策略，因此地址会变化，需要该插入位置的内存偏移量 */</span></span><br><span class="line">    offset = p-zl;</span><br><span class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class="line">    p = zl+offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</span><br><span class="line">        offset = p-zl;</span><br><span class="line">      	<span class="comment">/* 判断是否级联更新 */</span></span><br><span class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class="line">        p = zl+offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从整个流程的前半部分来看，在插入一个新节点时，也需要计算<strong><prevlen> <encoding> <entry-data></strong>三个部分的大小</p>
<ol>
<li>ZIP_DECODE_PREVLEN和zipRawEntryLength就是获取上一个节点的大小，后续通过zipStorePrevEntryLength求得编码之后的大小</li>
<li>通过判断插入节点的类型(字符串还是整数)获取entry-data的字节数</li>
<li>zipStoreEntryEncoding求得该节点的内容长度，并将长度编码存储在encoding部分(encoding的部分主要包含字符串类型和数字类型的类型信息)</li>
</ol>
<h4 id="级联更新"><a href="#级联更新" class="headerlink" title="级联更新"></a>级联更新</h4><p>在ziplist的设计上，通过prevlen存储上一个节点的字节大小可以通过通减去该值同时依赖于内存连续分配从而快速向前遍历，省去很多指针开销，但在上述插入场景中，如果待插入节点的字节大小过大，导致其后续节点的字节的prevlen值无法在1个字节内存储，那么就会导致后续节点的内存需再分配，然后最差情况就像多米诺骨牌效应一样，导致后续所有节点的内存都需要再分配。</p>
<p><img src="https://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/ziplist_cascade_update.png?x-oss-process=style/zsfimage" alt=""></p>
<p>插入的节点本身大小占用251bytes，加上两个字节的长度编码以及1byte的前一个节点的长度，后一个节点需要表示254bytes的prevlen，超出1个字节，导致后续内存再分配，如果zentry3本身大小也在250-253bytes之间的话，按照之前的计算规则，则继续上述操作，导致大量的内存拷贝，消耗CPU。这也是ziplist设计上的缺点。</p>
<p>从上述情况看，要想产生最坏情况下的级联更新的前期条件：待插入节点大小介入250-253bytes之间，包括后续节点也是介入这个之间。概率不大，并且即使产生这种情况，只要节点数量不多的话，还是没有太大的关系。但是Redis还是不想寄希望于不可控的”运气”，在5.0的版本中引入了listpack(紧凑列表)这种数据结构来希望后续替换ziplist，在listpack中每个节点只存自己的字节大小。存在在节点的尾部，这样直接通过总大小减去尾部的节点大小算出最后一个节点的偏移量。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综上来看，Redis的内存优化上有以下几个特点：</p>
<ol>
<li>数字类型优先，对于内容为数字的value，会将其转换为数字存储</li>
<li>内存分配尽量保证连续，这样可以避免内存碎片，同时节省指针的内存消耗</li>
<li>对于同一个数据结构，存在多种编码方式，在能存储内容地情况下，尽量选择内存占用更优的编码方式</li>
</ol>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://zsfblues.github.io">zsfblues</a></p><p> <span>Link:  </span><a href="http://zsfblues.github.io/2020/05/08/%E6%B5%85%E8%B0%88Redis%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1/">http://zsfblues.github.io/2020/05/08/%E6%B5%85%E8%B0%88Redis%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/3.0" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="nextSlogan" href="/2019/02/17/RocketMQ%E5%AD%A6%E4%B9%A0-%E5%9B%9B-consumer/" title="RocketMQ学习-四-consumer"><span>NextPost ></span><br><span class="nextTitle">RocketMQ学习-四-consumer</span></a><div class="clear"></div></div><div id="comment"><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: '浅谈Redis中的内存优化设计',
  owner: '9928627',
  repo: 'zsfblues.github.io',
  oauth: {
    client_id: '27ef90191eda06aadd5b',
    client_secret: 'f2ed675c18da0938f480e4eef3cf44d480f6d801',
  },
})
gitment.render('container')</script></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo" target="_blank" rel="noopener"><span>Cxo</span></a></p></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#设计上的缺点"><span class="toc-number">1.</span> <span class="toc-text">设计上的缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ziplist"><span class="toc-number"></span> <span class="toc-text">ziplist</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串类型设计"><span class="toc-number">1.</span> <span class="toc-text">字符串类型设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数字类型设计"><span class="toc-number">2.</span> <span class="toc-text">数字类型设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#级联更新"><span class="toc-number">3.</span> <span class="toc-text">级联更新</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number"></span> <span class="toc-text">总结</span></a></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>