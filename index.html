<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="zsfblues"><meta name="renderer" content="webkit"><meta name="copyright" content="zsfblues"><meta name="keywords" content="zsfblues' blog"><meta name="description" content="IT,互联网"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>zsfblues' blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/me.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><meta name="generator" content="Hexo 4.2.0"></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/me.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">zsfblues</div><div class="profile-signature">zsfblues' blog</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">zsfblues' blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div></i><div class="clear"></div></section></nav><h1>zsfblues' blog</h1><h5>魔鬼隐藏在细节中</h5><div class="intro-social"><a class="fa fa-envelope" href="mailto://zhoushengfan1994@163.com" title="email"></a><a class="fa fa-github" href="//github.com/zsfblues" target="_blank" title="github"></a><a class="fa fa-lightbulb-o" href="https://www.zhihu.com/people/zsfblues/" target="_blank" title="lightbulb-o"></a></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><section id="recent-posts"><div class="recent-post-item"><div class="post-title"><a href="/2020/05/08/%E6%B5%85%E8%B0%88Redis%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1/">浅谈Redis中的内存优化设计</a></div><div class="post-time"><i class="fa fa-table"></i><time datetime="2020-05-08T14:40:57.000Z">2020-05-08</time></div><div class="recent-post-content">Redis作为一个高效的kv型键值型数据库，除了依赖内存高效处理读写操作外，在节约内存的设计上也有着近乎于苛刻，总是想尽一切办法来节约内存，本次主要结合两个比较典型的数据结构上的设计来一窥Redis中的内存优化之道：sds和ziplist。

在介绍这两个数据结构之前，我们先聊一下基础数据结构：robj。
从Redis的使用者的角度来看，一个Redis节点包含多个db（非cluster模式下默认是16个，cluster模式下只能是1个），而一个db就是维护了从key 到value的映射关系。key只能是string类型，而value可以是多种数据类型，比如：string，list，hash，z ...</div><div class="recent-post-tags"><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="Redis"> Redis</a></div><div class="read-more"><a class="more" href="/2020/05/08/%E6%B5%85%E8%B0%88Redis%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1/#more">ReadMore</a></div><hr></div><div class="recent-post-item"><div class="post-title"><a href="/2019/02/17/RocketMQ%E5%AD%A6%E4%B9%A0-%E5%9B%9B-consumer/">RocketMQ学习-四-consumer</a></div><div class="post-time"><i class="fa fa-table"></i><time datetime="2019-02-17T12:39:19.000Z">2019-02-17</time></div><div class="recent-post-content">
​    作为消息中间件的重要组成部分，消费者的作用的主要在于下游接收producer产生的消息数据，以便在业务系统中处理相应的逻辑。
它的整个消费流程借用某位大牛的图片：

​    消息的消费模型一般说来有两种：推模型(Push)和拉模型(Pull)，不过这两种常规的模型都有着一些问题，push模型一般由消息的推送者在发出新消息后主动对下游的消费者进行推送，如果推送的速率过快导致消费方消费不过来(比如下游有一些IO操作，或者请求三方服务的操作相对耗时)就会导致消费方负载过高，这时候推送方又不能及时了解下游消费方的状态(实现这点往往又会增加推送方的复杂度)，有可能会导致下游宕机。而传统的p ...</div><div class="recent-post-tags"><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="RocketMQ"> RocketMQ</a><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="消息中间件"> 消息中间件</a></div><div class="read-more"><a class="more" href="/2019/02/17/RocketMQ%E5%AD%A6%E4%B9%A0-%E5%9B%9B-consumer/#more">ReadMore</a></div><hr></div><div class="recent-post-item"><div class="post-title"><a href="/2018/11/25/RocketMQ%E5%AD%A6%E4%B9%A0-%E4%BA%8C-broker/">RocketMQ学习(二) broker</a></div><div class="post-time"><i class="fa fa-table"></i><time datetime="2018-11-25T12:36:35.000Z">2018-11-25</time></div><div class="recent-post-content">​    broker的启动和producer一样，启动时会同时启动多个定时任务，包括消息持久化，netty客户端启动，监听文件内容变更的等等…

消息持久化消息持久化是broker最重要的任务，其稳定与否关系到消费者是否能消费到消息，整个mq是否会丢消息。
1234567891011121314151617181920212223242526272829303132public void start() throws Exception &#123;       lock = lockFile.getChannel().tryLock(0, 1, false);       if (lock ...</div><div class="recent-post-tags"><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="RocketMQ"> RocketMQ</a><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="消息中间件"> 消息中间件</a></div><div class="read-more"><a class="more" href="/2018/11/25/RocketMQ%E5%AD%A6%E4%B9%A0-%E4%BA%8C-broker/#more">ReadMore</a></div><hr></div><div class="recent-post-item"><div class="post-title"><a href="/2018/08/25/RocketMQ%E5%AD%A6%E4%B9%A0-%E4%B8%89-producer/">RocketMQ学习(三) producer</a></div><div class="post-time"><i class="fa fa-table"></i><time datetime="2018-08-25T09:27:36.000Z">2018-08-25</time></div><div class="recent-post-content">RockterMq本质上作为一个高性能的消息中间件，通过消息来联动各个系统的状态，作为消息发起方的producer自然有必要了解一下其中的原理。讲解以官方demo为基础。

数据初始化在实例化一个producer之后，首先需要进行一系列数据初始化，这些初始化操作为后面的数据发送奠定基础。
以默认的DefaultMQProducer类为例：
12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void start(final boolean startFactory)  ...</div><div class="recent-post-tags"><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="RocketMQ"> RocketMQ</a><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="消息中间件"> 消息中间件</a></div><div class="read-more"><a class="more" href="/2018/08/25/RocketMQ%E5%AD%A6%E4%B9%A0-%E4%B8%89-producer/#more">ReadMore</a></div><hr></div><div class="recent-post-item"><div class="post-title"><a href="/2018/06/24/RocketMQ%E5%AD%A6%E4%B9%A0-namesrv/">RocketMQ学习(一) namesrv</a></div><div class="post-time"><i class="fa fa-table"></i><time datetime="2018-06-24T10:03:30.000Z">2018-06-24</time></div><div class="recent-post-content">前言因为最近项目的原因用上了消息队列，且技术选型用的是RocketMQ，因而抽空花时间研究了一下其中的几个核心组件的原理(包括namesrv，broker，consumer，producer，当然RocketMQ如何处理消息堆积以及消息落盘的处理也是精华)。本文的分析是基于RocketMQ—4.3版本源码。
首先依据RocketMQ的官方文档明确以下几个概念，方便后续描述：

Producer：消息生产者，负责产生消息，一般由业务系统负责产生消息。

Consumer：消息消费者，负责消费消息，一般是后台系统负责异步消费。
2.1 Push Consumer：Consumer 的一种，应用通常 ...</div><div class="recent-post-tags"><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="RocketMQ"> RocketMQ</a><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="消息中间件"> 消息中间件</a></div><div class="read-more"><a class="more" href="/2018/06/24/RocketMQ%E5%AD%A6%E4%B9%A0-namesrv/#more">ReadMore</a></div><hr></div><div class="recent-post-item"><div class="post-title"><a href="/2018/02/04/Spring-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%B0%8F%E7%BB%93/">Spring 异常处理机制小结</a></div><div class="post-time"><i class="fa fa-table"></i><time datetime="2018-02-04T10:28:01.000Z">2018-02-04</time></div><div class="recent-post-content">前几天想把公司某个项目中的参数处理通过某一种统一的机制进行封装后并将返回结果统一处理，参照资料后发现可以通过
JSR之前定义的一些参数校验标准来对一些进行简单的设置

javax.validation.constraints包下面有如下注解:



注解
数据类型
说明



@Null
任意类型
必须为空


@NotNull
任意类型
必须不为空


@AssertFalse
boolean,Boolean
注解布尔值为false


@AssertTrue
同@AssertFalse
注解布尔值为true


@Max(value=值)
BigDecimal，BigInteger, by ...</div><div class="recent-post-tags"><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="Spring"> Spring</a></div><div class="read-more"><a class="more" href="/2018/02/04/Spring-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%B0%8F%E7%BB%93/#more">ReadMore</a></div><hr></div><div class="recent-post-item"><div class="post-title"><a href="/2018/01/21/%E5%9F%BA%E7%A1%80%E5%90%8C%E6%AD%A5%E6%A1%86%E6%9E%B6-AbstractQueuedSynchronizer/">基础同步框架 - AbstractQueuedSynchronizer</a></div><div class="post-time"><i class="fa fa-table"></i><time datetime="2018-01-21T10:28:01.000Z">2018-01-21</time></div><div class="recent-post-content">​    AbstractQueuedSynchronizer作为JUC包下面基础同步框架，为很多并发集合的提供许多基础的同步方法，它大体上分为两种同步模式：独占模式(ReentrantLock)以及共享模式(CountDownLatch)，但AbstractQueuedSynchronizer本身并不提供两种模式的具体实现，它的很多方法都交由子类在不同场景下进行按需实现，它最重大的作用实在内部构建一种CLH队列，由内部类 Node作为基础元素，它将入队的线程及其所处的模式关联起来。CLH 中的每个结点都必须由其前驱结点来唤醒。

​    在AQS内部，通过将线程抽象为一个个Node对象存储 ...</div><div class="recent-post-tags"><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="并发框架"> 并发框架</a><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="队列"> 队列</a></div><div class="read-more"><a class="more" href="/2018/01/21/%E5%9F%BA%E7%A1%80%E5%90%8C%E6%AD%A5%E6%A1%86%E6%9E%B6-AbstractQueuedSynchronizer/#more">ReadMore</a></div><hr></div><div class="recent-post-item"><div class="post-title"><a href="/2016/09/03/%E6%9C%89%E5%BA%8F%E7%9A%84HashMap-LinkedHashMap/">有序的HashMap-LinkedHashMap</a></div><div class="post-time"><i class="fa fa-table"></i><time datetime="2016-09-03T11:54:38.000Z">2016-09-03</time></div><div class="recent-post-content">​    LinkedHashMap作为一个可以按插入顺序遍历的Map集合，在许多功能上和HashMap是重叠，这也难怪，谁叫LinkedHashMap是HashMap的子类。不仅如此，LinkedHashMap还可以根据近期访问某个键值对的顺序（从近期访问最少到近期访问最多的顺序）来遍历元素，这可让需要利用LRU方法进行缓存结果的用户提供一个新的解决方案。

LinkedHashMap中有一个核心元素：
123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;      Entry&lt;K,V&gt ...</div><div class="recent-post-tags"><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="集合框架"> 集合框架</a></div><div class="read-more"><a class="more" href="/2016/09/03/%E6%9C%89%E5%BA%8F%E7%9A%84HashMap-LinkedHashMap/#more">ReadMore</a></div><hr></div><div class="recent-post-item"><div class="post-title"><a href="/2016/07/20/ThreadPoolExecutor%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/">ThreadPoolExecutor的原理和设计思想</a></div><div class="post-time"><i class="fa fa-table"></i><time datetime="2016-07-20T11:58:09.000Z">2016-07-20</time></div><div class="recent-post-content">在多线程编程十分普遍的今天，很多人都在用多线程来尽量榨干CPU的性能。但常规地为每个任务创建线程却有以下不足:


创建线程的消耗较高：线程作为CPU分配时间片的基本单位，较多的线程可能会引起CPU频繁地在不同的线程中切换，以至于CPU没有过多的精力来处理任务
资源消耗大：每创建一个线程的话就会消耗一定的内存资源，当线程数量较大时，CPU就没有过多的精力来处理每一个线程任务，导致线程空占资源，同时给JVM回收线程资源带来较大的压力
平台相关性：仔细观察源码的话就会发现Java中的Thread类的很多方法都是native的，这表明很多实现都是调用底层的操作系统函数来实现。这让许多的参数，包括JV ...</div><div class="recent-post-tags"><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="线程池"> 线程池</a></div><div class="read-more"><a class="more" href="/2016/07/20/ThreadPoolExecutor%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/#more">ReadMore</a></div><hr></div><div class="recent-post-item"><div class="post-title"><a href="/2016/06/16/%E4%BC%98%E7%A7%80%E5%8D%9A%E5%AE%A2%E9%93%BE%E6%8E%A5%E6%B1%87%E6%80%BB-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/">优秀博客链接汇总(长期更新)</a></div><div class="post-time"><i class="fa fa-table"></i><time datetime="2016-06-16T12:06:23.000Z">2016-06-16</time></div><div class="recent-post-content">博主学习新知识的途径主要有以下几种：

官方文档：这往往是学习一种新知识较为正式且权威的方式(更新速度也是最快的)，毕竟官方出品，必属精品嘛。但有时候描述语言较为抽象且正式，理解起来有时较为晦涩，而且有时候英语会折磨相当一部分人(当然博主还是没什么太大压力的O(∩_∩)O~)
视频：这种方式往往较为生动，长期学习不容易让人产生烦闷的学习心态。但对知识的掌握较为快餐化，我们只能学到一些表面的东西，比如框架的话往往只能学到如何使用这一层面，对于原理以及设计方面的讲解就较为粗浅
相关书籍：这也是博主较为常用和喜欢的一种方式，所谓学到老，活到老(不好意思，说反了o(╯□╰)o)，书籍往往在保证知识的系 ...</div><div class="recent-post-tags"><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="博客"> 博客</a></div><div class="read-more"><a class="more" href="/2016/06/16/%E4%BC%98%E7%A7%80%E5%8D%9A%E5%AE%A2%E9%93%BE%E6%8E%A5%E6%B1%87%E6%80%BB-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/#more">ReadMore</a></div><hr></div></section><nav class="cxo-page-nav"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">NEXT &amp;#62;</a></nav></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo" target="_blank" rel="noopener"><span>Cxo</span></a></p></div></footer><!-- catelog--><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>