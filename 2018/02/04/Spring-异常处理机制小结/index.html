<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="zsfblues"><meta name="renderer" content="webkit"><meta name="copyright" content="zsfblues"><meta name="keywords" content="zsfblues' blog"><meta name="description" content="IT,互联网"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Spring 异常处理机制小结 · zsfblues' blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/me.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><meta name="generator" content="Hexo 4.2.0"></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/me.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">zsfblues</div><div class="profile-signature">zsfblues' blog</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">zsfblues' blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">Spring 异常处理机制小结</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2018/02/04</span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="Spring"> Spring</a></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><p>前几天想把公司某个项目中的参数处理通过某一种统一的机制进行封装后并将返回结果统一处理，参照资料后发现可以通过</p>
<p>JSR之前定义的一些参数校验标准来对一些进行简单的设置</p>
<blockquote>
<p>javax.validation.constraints包下面有如下注解:</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Null</td>
<td>任意类型</td>
<td>必须为空</td>
</tr>
<tr>
<td>@NotNull</td>
<td>任意类型</td>
<td>必须不为空</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>boolean,Boolean</td>
<td>注解布尔值为false</td>
</tr>
<tr>
<td>@AssertTrue</td>
<td>同@AssertFalse</td>
<td>注解布尔值为true</td>
</tr>
<tr>
<td>@Max(value=值)</td>
<td>BigDecimal，BigInteger, byte,short, int, long，等任何Number</td>
<td>设置最大值</td>
</tr>
<tr>
<td>@Min(value=值)</td>
<td>同@Min</td>
<td>设置最小值</td>
</tr>
<tr>
<td>@DecimalMax(value=值)</td>
<td>同@Min</td>
<td>设置最大值</td>
</tr>
<tr>
<td>@Digits(integer=整数位数,fraction=小数位数)</td>
<td>同@Min</td>
<td>设置整数位和小数位的精度</td>
</tr>
<tr>
<td>@Future</td>
<td>java.util.Date,java.util.Calendar;Joda Time类库的日期类型</td>
<td>比当前时间晚</td>
</tr>
<tr>
<td>@Past</td>
<td>同@Future</td>
<td>比当前时间早</td>
</tr>
<tr>
<td>@Size(min=最小值,max=最大值)</td>
<td>字符串、Collection、Map、数组等</td>
<td>长度</td>
</tr>
<tr>
<td>@Pattern(regexp=正则表达式)</td>
<td>String</td>
<td>匹配正则表达式</td>
</tr>
</tbody></table>
<p>除此之外，还有Hibernate Validation提供的注解：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Range(min=最小值, max=最大值)</td>
<td>同@Min</td>
<td>验证注解的元素值在最小值和最大值之间</td>
</tr>
<tr>
<td>@URL</td>
<td>String</td>
<td>校验URL格式</td>
</tr>
<tr>
<td>@Email</td>
<td>String</td>
<td>校验Email格式</td>
</tr>
<tr>
<td>@NotBlank</td>
<td>String</td>
<td>不为null,不为””</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>任意类型</td>
<td>不为null,字符串长度不为0,集合大小不为0</td>
</tr>
</tbody></table>
</blockquote>
<pre><code>通过在一个 pojo 对象的 field 中加上这些注解并在 Controller 层对应的 pojo 对象前加上@Valid 注解就可以使用，并将校验不通过的异常信息包装在一个 BindingResult对象，整个处理十分方便，具体用法网上有很多，就不赘述了。</code></pre><hr>
<pre><code>上述对于这种校验需要包装一个完整的 pojo 对象，有时候在入参不多的情况下有点多余，一般就是对指定的参数校验，我就想在参数校验不通过的情况下对异常信息统一处理，于是马上想到可以通过 ExceptionHandler + ControllerAdvice注解的方式对进行统一处理，对于ConstraintViolationException这个异常进行捕获就可以了，可惜理想丰满现实骨感。在 web 容器加载后请求对应的mapping始终没有在@ExceptionHandler修饰的方法中捕获异常，这个配置方法和Spring提供的教程相差无几，为什么会没有处理…</code></pre><h3 id="Spring-统一的异常处理接口HandlerExceptionResolver"><a href="#Spring-统一的异常处理接口HandlerExceptionResolver" class="headerlink" title="Spring 统一的异常处理接口HandlerExceptionResolver"></a>Spring 统一的异常处理接口HandlerExceptionResolver</h3><p> 在 Spring 的整个异常处理体系中，HandlerExceptionResolver接口是一个基础入口，其中的resolveException方法专门用于处理请求过程中发生的Exception，参数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span>;</span><br></pre></td></tr></table></figure>



<p>在对源码进行调试之后，发现请求流程中如下：</p>
<ol>
<li><p>对于所有的 http 请求，通过DispatcherServlet这个类进行分发，这个类是一个核心请求类，处理包括但不限于</p>
<ul>
<li>将请求参数请求解析并将解析后的参数放入 RequestMapping 修饰的方法的入参中</li>
<li>调用定义好的拦截器对方法进行增强</li>
<li>根据HttpServletRequest对象类型 将请求正确分发到对应 HandlerAdapter中</li>
<li>将处理好的请求结果封装到一个 ModelAndView 对象中返回，如果是直接返回到一个结果页面还要进行视图的渲染</li>
<li>对请求过程中异常的处理</li>
</ul>
</li>
<li><p>在请求处理完成后，有如下代码(省略一些次要代码，下同)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		HttpServletRequest processedRequest = request;</span><br><span class="line">		HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">			Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// Determine handler for the current request.</span></span><br><span class="line">				mappedHandler = getHandler(processedRequest);</span><br><span class="line">				<span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">					noHandlerFound(processedRequest, response);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">				HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">				<span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Actually invoke the handler.</span></span><br><span class="line">				mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">				mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">				dispatchException = ex;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">				<span class="comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></span><br><span class="line">				<span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">				dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">			&#125;</span><br><span class="line">			processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">			triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">					<span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 在请求完成后会有对异常的检查和处理，由processDispatchResult方法的processHandlerException处理</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">processHandlerException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ModelAndView exMv = <span class="keyword">null</span>;</span><br><span class="line">  		<span class="comment">// 遍历之前应用启动时所有在IOC容器中注册的异常处理器(都基于HandlerExceptionResolver接口)</span></span><br><span class="line">		<span class="keyword">for</span> (HandlerExceptionResolver handlerExceptionResolver : <span class="keyword">this</span>.handlerExceptionResolvers) &#123;</span><br><span class="line">			exMv = handlerExceptionResolver.resolveException(request, response, handler, ex);</span><br><span class="line">			<span class="keyword">if</span> (exMv != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>看到这里，基本可以发现大致的问题，我的这个项目在启动时只有项目的异常配置ExceptionResolver，于是我又新建一个可以使用@ExceptionHandler注解的项目，观察它的ExceptionResolver类型，对比后发现：</p>
<p>失效配置</p>
<p><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/006HiYd9ly1g09qr5kyhij30xu076400.jpg" alt=""></p>
<p>正常配置</p>
<p><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/006HiYd9ly1g09qr5l4p5j30vm080wg6.jpg" alt=""></p>
<p>继续跟踪一下发现在<strong>ExceptionHandlerExceptionResolver</strong>这个异常处理器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExceptionHandlerExceptionResolver内部用两个Map来存储所有ExceptionHandlerMethodResolver类，</span></span><br><span class="line"><span class="comment">// 他并不直接实现HandlerExceptionResolver接口，而是靠外部其它类来包装</span></span><br><span class="line"><span class="comment">// 在ExceptionHandlerMethodResolver中会去发现所有由@ExceptionHandler修饰的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, ExceptionHandlerMethodResolver&gt; exceptionHandlerCache =</span><br><span class="line">			<span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, ExceptionHandlerMethodResolver&gt;(<span class="number">64</span>); <span class="comment">// 处理具体 Controller中的ExceptionHandler</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ControllerAdviceBean, ExceptionHandlerMethodResolver&gt; exceptionHandlerAdviceCache =</span><br><span class="line">			<span class="keyword">new</span> LinkedHashMap&lt;ControllerAdviceBean, ExceptionHandlerMethodResolver&gt;(); <span class="comment">//处理ControllerAdvice中的ExceptionHandler</span></span><br></pre></td></tr></table></figure>

<h3 id="Spring-中异常处理方式"><a href="#Spring-中异常处理方式" class="headerlink" title="Spring 中异常处理方式"></a>Spring 中异常处理方式</h3><p>很显然，Spring 对于异常的处理有以下几种方式：</p>
<ol>
<li>某一具体Controller方法中抛出的异常，由Controller中有@ExceptionHandler修饰的方法处理(如果异常类型可以匹配上的话)</li>
<li>通过ControllerAdvice + ExceptionHandler注解相结合的方法全局处理各个Controller中的异常</li>
<li>自定义异常解析器并实现HandlerExceptionResolver接口</li>
</ol>
<p>而在我这个ExceptionHandler注解失效项目中，显然采用第三种方法处理异常，并且我采用了@EnableWebMvc注解作为全局的 web 配置，默认这个配置会读取WebMvcConfigurationSupport这个类中的配置；但不幸的是这个配置会被继承WebMvcConfigurerAdapter或实现WebMvcConfigurer接口的配置类所覆盖，我们项目中正好继承了WebMvcConfigurerAdapter类并且只添加了一种自定义的异常解析器作为全局处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// Java Doc 中对WebMvcConfigurationSupport异常解析器的部分描述</span></span><br><span class="line">&gt; Registers a &#123;<span class="meta">@link</span> HandlerExceptionResolverComposite&#125; with <span class="keyword">this</span> chain of</span><br><span class="line">&gt; exception resolvers:</span><br><span class="line">&gt;</span><br><span class="line">&gt; &#123;<span class="meta">@link</span> ExceptionHandlerExceptionResolver&#125; <span class="keyword">for</span> handling exceptions</span><br><span class="line">&gt; through @&#123;<span class="meta">@link</span> ExceptionHandler&#125; methods.</span><br><span class="line">&gt; &#123;<span class="meta">@link</span> ResponseStatusExceptionResolver&#125; <span class="keyword">for</span> exceptions annotated</span><br><span class="line">&gt; with @&#123;<span class="meta">@link</span> ResponseStatus&#125;.</span><br><span class="line">&gt; &#123;<span class="meta">@link</span> DefaultHandlerExceptionResolver&#125; <span class="keyword">for</span> resolving known Spring</span><br><span class="line">&gt; exception types</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<pre><code>看到这里，有人会问，当初继承WebMvcConfigurerAdapter这个类自定义配置是为了满足业务需求，尤其是异常这块希望有一个全局处理机制，但后来发现需要对某一特定异常进行处理的时候却发现ExceptionHandler注解失效，难道不能两种兼得吗？答案当然是可以，仔细查阅 Spring WebMvcConfigurer源码中的 Java Doc 发现，自定义的异常解析器有两种添加方法： </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以覆盖WebMvcConfigurationSupport的默认解析器方法重新定义异常解析器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureHandlerExceptionResolvers</span><span class="params">(List&lt;HandlerExceptionResolver&gt; exceptionResolvers)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以继承WebMvcConfigurationSupport的默认解析器方法扩展异常解析器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendHandlerExceptionResolvers</span><span class="params">(List&lt;HandlerExceptionResolver&gt; exceptionResolvers)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，第二种就能满足我们的需求了，效果如下：</p>
<p><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/006HiYd9ly1g09qr5rx3hj30ue0awmzb.jpg" alt=""></p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://zsfblues.github.io">zsfblues</a></p><p> <span>Link:  </span><a href="http://zsfblues.github.io/2018/02/04/Spring-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%B0%8F%E7%BB%93/">http://zsfblues.github.io/2018/02/04/Spring-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%B0%8F%E7%BB%93/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/3.0" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2018/06/24/RocketMQ%E5%AD%A6%E4%B9%A0-namesrv/" title="RocketMQ学习(一) namesrv"><span>< PreviousPost</span><br><span class="prevTitle">RocketMQ学习(一) namesrv</span></a><a class="nextSlogan" href="/2018/01/21/%E5%9F%BA%E7%A1%80%E5%90%8C%E6%AD%A5%E6%A1%86%E6%9E%B6-AbstractQueuedSynchronizer/" title="基础同步框架 - AbstractQueuedSynchronizer"><span>NextPost ></span><br><span class="nextTitle">基础同步框架 - AbstractQueuedSynchronizer</span></a><div class="clear"></div></div><div id="comment"><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: 'Spring 异常处理机制小结',
  owner: '9928627',
  repo: 'zsfblues.github.io',
  oauth: {
    client_id: '27ef90191eda06aadd5b',
    client_secret: 'f2ed675c18da0938f480e4eef3cf44d480f6d801',
  },
})
gitment.render('container')</script></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo" target="_blank" rel="noopener"><span>Cxo</span></a></p></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-统一的异常处理接口HandlerExceptionResolver"><span class="toc-number">1.</span> <span class="toc-text">Spring 统一的异常处理接口HandlerExceptionResolver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-中异常处理方式"><span class="toc-number">2.</span> <span class="toc-text">Spring 中异常处理方式</span></a></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>