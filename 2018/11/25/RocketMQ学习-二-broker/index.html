<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="zsfblues"><meta name="renderer" content="webkit"><meta name="copyright" content="zsfblues"><meta name="keywords" content="zsfblues' blog"><meta name="description" content="IT,互联网"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>RocketMQ学习(二) broker · zsfblues' blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/me.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><meta name="generator" content="Hexo 4.2.0"></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/me.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">zsfblues</div><div class="profile-signature">zsfblues' blog</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">zsfblues' blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">RocketMQ学习(二) broker</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2018/11/25</span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="RocketMQ"> RocketMQ</a><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="消息中间件"> 消息中间件</a></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><p>​    broker的启动和producer一样，启动时会同时启动多个定时任务，包括消息持久化，netty客户端启动，监听文件内容变更的等等…</p>
<hr>
<h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>消息持久化是broker最重要的任务，其稳定与否关系到消费者是否能消费到消息，整个mq是否会丢消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">       lock = lockFile.getChannel().tryLock(<span class="number">0</span>, <span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line">       <span class="keyword">if</span> (lock == <span class="keyword">null</span> || lock.isShared() || !lock.isValid()) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Lock failed,MQ already started"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       lockFile.getChannel().write(ByteBuffer.wrap(<span class="string">"lock"</span>.getBytes()));</span><br><span class="line">       lockFile.getChannel().force(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">       <span class="keyword">this</span>.flushConsumeQueueService.start();</span><br><span class="line">       <span class="keyword">this</span>.commitLog.start();</span><br><span class="line">       <span class="keyword">this</span>.storeStatsService.start();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.scheduleMessageService != <span class="keyword">null</span> &amp;&amp; SLAVE != messageStoreConfig.getBrokerRole()) &#123;</span><br><span class="line">           <span class="keyword">this</span>.scheduleMessageService.start();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageStoreConfig().isDuplicationEnable()) &#123;</span><br><span class="line">           <span class="keyword">this</span>.reputMessageService.setReputFromOffset(<span class="keyword">this</span>.commitLog.getConfirmOffset());</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.reputMessageService.setReputFromOffset(<span class="keyword">this</span>.commitLog.getMaxOffset());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">this</span>.reputMessageService.start();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.haService.start();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.createTempFile();</span><br><span class="line">       <span class="keyword">this</span>.addScheduleTask();</span><br><span class="line">       <span class="keyword">this</span>.shutdown = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>flushConsumeQueueService作用是用来持久化一些producer发送到对应topic中的的不同队列的消息，核心代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentMap&lt;String, ConcurrentMap&lt;Integer, ConsumeQueue&gt;&gt; tables = DefaultMessageStore.<span class="keyword">this</span>.consumeQueueTable;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 针对不同topic的每个消费队列进行消息读取并刷新到commitLog</span></span><br><span class="line">         <span class="keyword">for</span> (ConcurrentMap&lt;Integer, ConsumeQueue&gt; maps : tables.values()) &#123;</span><br><span class="line">             <span class="keyword">for</span> (ConsumeQueue cq : maps.values()) &#123;</span><br><span class="line">                 <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; retryTimes &amp;&amp; !result; i++) &#123;</span><br><span class="line">                     result = cq.flush(flushConsumeQueueLeastPages);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">flush</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> flushLeastPages)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">     MappedFile mappedFile = <span class="keyword">this</span>.findMappedFileByOffset(<span class="keyword">this</span>.flushedWhere, <span class="keyword">this</span>.flushedWhere == <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">long</span> tmpTimeStamp = mappedFile.getStoreTimestamp();</span><br><span class="line">         <span class="keyword">int</span> offset = mappedFile.flush(flushLeastPages);</span><br><span class="line">         <span class="keyword">long</span> where = mappedFile.getFileFromOffset() + offset;</span><br><span class="line">         result = where == <span class="keyword">this</span>.flushedWhere;</span><br><span class="line">         <span class="keyword">this</span>.flushedWhere = where;</span><br><span class="line">         <span class="keyword">if</span> (<span class="number">0</span> == flushLeastPages) &#123;</span><br><span class="line">             <span class="keyword">this</span>.storeTimestamp = tmpTimeStamp;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>其中flushConsumeQueueLeastPages用来确定一次最终刷多少页的数据到磁盘，findMappedFileByOffset方法可以确定当前应该刷新哪个文件中，因为在commitLog中维护一个名为mapedFileQueue的文件映射队列，这个队列记录了所有的记录消息的映射文件。每个文件大小默认为1G。这样通过上次刷新的偏移量就能确定mapedFile。值得注意的时，在往文件中写的时候，会去检验文件是否可以写入(是否写满)，以及当前已写入到内存中的数据是否可以刷入指定页数的数据到磁盘，如果flushLeastPages 等于0的话就一次性将所有可以的落盘的数据一次性刷入磁盘(OS_PAGE_SIZE为操作系统默认的页大小)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (flushLeastPages &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &gt;= flushLeastPages;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> write &gt; flush;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终刷盘的代码</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">                </span><br><span class="line">       <span class="keyword">if</span> (writeBuffer != <span class="keyword">null</span> || <span class="keyword">this</span>.fileChannel.position() != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.fileChannel.force(<span class="keyword">false</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.mappedByteBuffer.force();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">       log.error(<span class="string">"Error occurred when force data to disk."</span>, e);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>FileChannel.force()方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点，需要调用force()方法。参数标明是否将元数据一同刷入。</p>
<p><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/mw690/006HiYd9ly1g0oihjp0mrj313e0nw0um.jpg" alt=""></p>
<ol start="2">
<li>commitLog刷盘</li>
</ol>
<p>主要有两种刷盘方式进行选择：</p>
<ol>
<li>同步刷盘</li>
<li>异步刷盘(默认方式)</li>
</ol>
<p>刷盘方式在初始化commitLog指定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CommitLog</span><span class="params">(<span class="keyword">final</span> DefaultMessageStore defaultMessageStore)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mappedFileQueue = <span class="keyword">new</span> MappedFileQueue(defaultMessageStore.getMessageStoreConfig().getStorePathCommitLog(),</span><br><span class="line">        defaultMessageStore.getMessageStoreConfig().getMapedFileSizeCommitLog(), defaultMessageStore.getAllocateMappedFileService());</span><br><span class="line">    <span class="keyword">this</span>.defaultMessageStore = defaultMessageStore;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FlushDiskType.SYNC_FLUSH == defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.flushCommitLogService = <span class="keyword">new</span> GroupCommitService();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.flushCommitLogService = <span class="keyword">new</span> FlushRealTimeService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.commitLogService = <span class="keyword">new</span> CommitRealTimeService();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.appendMessageCallback = <span class="keyword">new</span> DefaultAppendMessageCallback(defaultMessageStore.getMessageStoreConfig().getMaxMessageSize());</span><br><span class="line">    batchEncoderThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;MessageExtBatchEncoder&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> MessageExtBatchEncoder <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MessageExtBatchEncoder(defaultMessageStore.getMessageStoreConfig().getMaxMessageSize());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.putMessageLock = defaultMessageStore.getMessageStoreConfig().isUseReentrantLockWhenPutMessage() ? <span class="keyword">new</span> PutMessageReentrantLock() : <span class="keyword">new</span> PutMessageSpinLock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(1) 同步刷盘：GroupCommitService</p>
<p>同步刷盘策略在设计上比较巧妙，采用一种交换锁的方式来减少线程的竞争，具体方式为两个队列，初始状态下，写队列用来存储请求，同时不断在读队列中获取获取刷盘请求，当请求处理完成后迅速交换引用。写队列指向读队列，读队列指向写队列，而请求的来源来自另一个不断从处理发送的消息的定时任务中来</p>
<p>​    关于队列中的数据来源，比较典型的就是延时消息，在broker启动时同步会启动一个投递延时消息的定时任务，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有需要发送的延时消息</span></span><br><span class="line"><span class="keyword">if</span> (msgExt != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MessageExtBrokerInner msgInner = <span class="keyword">this</span>.messageTimeup(msgExt);</span><br><span class="line">        PutMessageResult putMessageResult =</span><br><span class="line">            ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore</span><br><span class="line">            .putMessage(msgInner);<span class="comment">// 这里开始发送消息</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (putMessageResult != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">            log.error(</span><br><span class="line">                <span class="string">"ScheduleMessageService, a message time up, but reput it failed, topic: &#123;&#125; msgId &#123;&#125;"</span>,</span><br><span class="line">                msgExt.getTopic(), msgExt.getMsgId());</span><br><span class="line">            ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(</span><br><span class="line">                <span class="keyword">new</span> DeliverDelayedMessageTimerTask(<span class="keyword">this</span>.delayLevel,</span><br><span class="line">                                                   nextOffset), DELAY_FOR_A_PERIOD);</span><br><span class="line">            ScheduleMessageService.<span class="keyword">this</span>.updateOffset(<span class="keyword">this</span>.delayLevel,</span><br><span class="line">                                                     nextOffset);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(</span><br><span class="line">            <span class="string">"ScheduleMessageService, messageTimeup execute error, drop it. msgExt="</span></span><br><span class="line">            + msgExt + <span class="string">", nextOffset="</span> + nextOffset + <span class="string">",offsetPy="</span></span><br><span class="line">            + offsetPy + <span class="string">",sizePy="</span> + sizePy, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Set the storage time</span></span><br><span class="line">        msg.setStoreTimestamp(System.currentTimeMillis());</span><br><span class="line">        <span class="comment">// Set the message body BODY CRC (consider the most appropriate setting</span></span><br><span class="line">        <span class="comment">// on the client)</span></span><br><span class="line">        msg.setBodyCRC(UtilAll.crc32(msg.getBody()));</span><br><span class="line">        <span class="comment">// Back to Results</span></span><br><span class="line">        AppendMessageResult result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        StoreStatsService storeStatsService = <span class="keyword">this</span>.defaultMessageStore.getStoreStatsService();</span><br><span class="line"></span><br><span class="line">        String topic = msg.getTopic();</span><br><span class="line">        <span class="keyword">int</span> queueId = msg.getQueueId();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line">        <span class="keyword">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE</span><br><span class="line">            || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line">            <span class="comment">// Delay Delivery</span></span><br><span class="line">            <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">                    msg.setDelayTimeLevel(<span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                topic = ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line">                queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Backup real topic, queueId</span></span><br><span class="line">                MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">                MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">                msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"></span><br><span class="line">                msg.setTopic(topic);</span><br><span class="line">                msg.setQueueId(queueId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> eclipseTimeInLock = <span class="number">0</span>;</span><br><span class="line">        MappedFile unlockMappedFile = <span class="keyword">null</span>;</span><br><span class="line">        MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile();</span><br><span class="line"></span><br><span class="line">        putMessageLock.lock(); <span class="comment">//spin or ReentrantLock ,depending on store config</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> beginLockTimestamp = <span class="keyword">this</span>.defaultMessageStore.getSystemClock().now();</span><br><span class="line">            <span class="keyword">this</span>.beginTimeInLock = beginLockTimestamp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Here settings are stored timestamp, in order to ensure an orderly</span></span><br><span class="line">            <span class="comment">// global</span></span><br><span class="line">            msg.setStoreTimestamp(beginLockTimestamp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile || mappedFile.isFull()) &#123;</span><br><span class="line">                mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>); <span class="comment">// Mark: NewFile may be cause noise</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile) &#123;</span><br><span class="line">                log.error(<span class="string">"create mapped file1 error, topic: "</span> + msg.getTopic() + <span class="string">" clientAddr: "</span> + msg.getBornHostString());</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 这里会对消息进行一定格式的组装</span></span><br><span class="line">            result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br><span class="line">          </span><br><span class="line">            eclipseTimeInLock = <span class="keyword">this</span>.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;</span><br><span class="line">            beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            putMessageLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eclipseTimeInLock &gt; <span class="number">500</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">"[NOTIFYME]putMessage in lock cost time(ms)=&#123;&#125;, bodyLength=&#123;&#125; AppendMessageResult=&#123;&#125;"</span>, eclipseTimeInLock, msg.getBody().length, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != unlockMappedFile &amp;&amp; <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.defaultMessageStore.unlockMappedFile(unlockMappedFile);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PutMessageResult putMessageResult = <span class="keyword">new</span> PutMessageResult(PutMessageStatus.PUT_OK, result);</span><br><span class="line">		<span class="comment">// 这里就是将数据放入队列中以便后续刷盘</span></span><br><span class="line">        handleDiskFlush(result, putMessageResult, msg);</span><br><span class="line">        handleHA(result, putMessageResult, msg);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> putMessageResult;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在appendMessage这个方法之中，会对要发送的消息进行数据格式的封装(主要格式见下表)以及消息格式，长度的的一些校验，并且将延时消息的topic替换成真实的topic(每一个延时消息为了不会被消费者提前消费，会用一个特殊的名叫<strong>SCHEDULE_TOPIC_XXXX</strong>的topic替换，该topic是不会注册到namesrv的)，最终将消息存储在commitLog之中以便后续消费者可以进行消费</p>
<p>(2) 异步刷盘：FlushRealTimeService</p>
<p>同步刷盘要求刷盘完成才处理下面的请求，吞吐量不是很好，异步刷盘则是则是在后台默默落盘，每隔一段时间就从内存缓冲区同步一些数据(默认是4页的数据)</p>
<p><strong>消息格式</strong></p>
<table>
<thead>
<tr>
<th>第几位</th>
<th>字段</th>
<th>说明</th>
<th>数据类型</th>
<th>字节数</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>MsgLen</td>
<td>消息总长度</td>
<td>Int</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>MagicCode</td>
<td>MESSAGE_MAGIC_CODE</td>
<td>Int</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>BodyCRC</td>
<td>消息内容CRC</td>
<td>Int</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>QueueId</td>
<td>消息队列编号</td>
<td>Int</td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td>Flag</td>
<td>flag</td>
<td>Int</td>
<td>4</td>
</tr>
<tr>
<td>6</td>
<td>QueueOffset</td>
<td>消息队列位置</td>
<td>Long</td>
<td>8</td>
</tr>
<tr>
<td>7</td>
<td>PhysicalOffset</td>
<td>物理位置。在 <code>CommitLog</code> 的顺序存储位置。</td>
<td>Long</td>
<td>8</td>
</tr>
<tr>
<td>8</td>
<td>SysFlag</td>
<td>MessageSysFlag</td>
<td>Int</td>
<td>4</td>
</tr>
<tr>
<td>9</td>
<td>BornTimestamp</td>
<td>生成消息时间戳</td>
<td>Long</td>
<td>8</td>
</tr>
<tr>
<td>10</td>
<td>BornHost</td>
<td>生效消息的地址+端口</td>
<td>Long</td>
<td>8</td>
</tr>
<tr>
<td>11</td>
<td>StoreTimestamp</td>
<td>存储消息时间戳</td>
<td>Long</td>
<td>8</td>
</tr>
<tr>
<td>12</td>
<td>StoreHost</td>
<td>存储消息的地址+端口</td>
<td>Long</td>
<td>8</td>
</tr>
<tr>
<td>13</td>
<td>ReconsumeTimes</td>
<td>重新消费消息次数</td>
<td>Int</td>
<td>4</td>
</tr>
<tr>
<td>14</td>
<td>PreparedTransationOffset</td>
<td></td>
<td>Long</td>
<td>8</td>
</tr>
<tr>
<td>15</td>
<td>BodyLength + Body</td>
<td>内容长度 + 内容</td>
<td>Int + Bytes</td>
<td>4 + bodyLength</td>
</tr>
<tr>
<td>16</td>
<td>TopicLength + Topic</td>
<td>Topic长度 + Topic</td>
<td>Byte + Bytes</td>
<td>1 + topicLength</td>
</tr>
<tr>
<td>17</td>
<td>PropertiesLength + Properties</td>
<td>拓展字段长度 + 拓展字段</td>
<td>Short + Bytes</td>
<td>2 + PropertiesLength</td>
</tr>
</tbody></table>
<p>除此之外，不论采取哪种刷盘策略，CommitRealTimeService这个服务是一定会初始化的，只不过需要在transientStorePoolEnable字段设为true才行并且刷盘策略为异步情况下且当且broker为master情况下才行，这样一来，CommitRealTimeService服务往往也是和FlushRealTimeService服务一起出现的</p>
<p>与FlushRealTimeService大部分的流程差不多，都是每次读取刷盘页数，然后找到对应的mappedFile进行写入，仔细观察却别在于一个调用flush方法，一个则是commit方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">flush</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> flushLeastPages)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">       MappedFile mappedFile = <span class="keyword">this</span>.findMappedFileByOffset(<span class="keyword">this</span>.flushedWhere, <span class="keyword">this</span>.flushedWhere == <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">long</span> tmpTimeStamp = mappedFile.getStoreTimestamp();</span><br><span class="line">           <span class="keyword">int</span> offset = mappedFile.flush(flushLeastPages);<span class="comment">//区别</span></span><br><span class="line">           <span class="keyword">long</span> where = mappedFile.getFileFromOffset() + offset;</span><br><span class="line">           result = where == <span class="keyword">this</span>.flushedWhere;</span><br><span class="line">           <span class="keyword">this</span>.flushedWhere = where;</span><br><span class="line">           <span class="keyword">if</span> (<span class="number">0</span> == flushLeastPages) &#123;</span><br><span class="line">               <span class="keyword">this</span>.storeTimestamp = tmpTimeStamp;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">commit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> commitLeastPages)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">// 获取上次所写入的commitLog 文件</span></span><br><span class="line">       MappedFile mappedFile = <span class="keyword">this</span>.findMappedFileByOffset(<span class="keyword">this</span>.committedWhere, <span class="keyword">this</span>.committedWhere == <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 找到文件后再写入这次的</span></span><br><span class="line">           <span class="keyword">int</span> offset = mappedFile.commit(commitLeastPages);<span class="comment">//区别</span></span><br><span class="line">           <span class="keyword">long</span> where = mappedFile.getFileFromOffset() + offset;</span><br><span class="line">           result = where == <span class="keyword">this</span>.committedWhere;</span><br><span class="line">           <span class="keyword">this</span>.committedWhere = where;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>而flush和commit方法细节如下(以下均省略细节)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//flush</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (writeBuffer != <span class="keyword">null</span> || <span class="keyword">this</span>.fileChannel.position() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fileChannel.force(<span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mappedByteBuffer.force();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    log.error(<span class="string">"Error occurred when force data to disk."</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//commit</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ByteBuffer byteBuffer = writeBuffer.slice();</span><br><span class="line">    byteBuffer.position(lastCommittedPosition);</span><br><span class="line">    byteBuffer.limit(writePos);</span><br><span class="line">    <span class="keyword">this</span>.fileChannel.position(lastCommittedPosition);</span><br><span class="line">    <span class="keyword">this</span>.fileChannel.write(byteBuffer);</span><br><span class="line">    <span class="comment">// 重置上次提交的位置</span></span><br><span class="line">    <span class="keyword">this</span>.committedPosition.set(writePos);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    log.error(<span class="string">"Error occurred when commit data to FileChannel."</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>commit方法会在每次执行时构造出一个写缓冲buffer，然后通过fileChannel进行写入，中间隔了一个内存字节缓存，而flush就简单粗暴一些，直接请求操作系统将数据一次性刷入磁盘(force是因为操作系统一般为了提高写入效率会将数据放在缓冲中批量写入，所以force可以强制要求其此时立即将数据写入)</p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://zsfblues.github.io">zsfblues</a></p><p> <span>Link:  </span><a href="http://zsfblues.github.io/2018/11/25/RocketMQ%E5%AD%A6%E4%B9%A0-%E4%BA%8C-broker/">http://zsfblues.github.io/2018/11/25/RocketMQ%E5%AD%A6%E4%B9%A0-%E4%BA%8C-broker/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/3.0" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2019/02/17/RocketMQ%E5%AD%A6%E4%B9%A0-%E5%9B%9B-consumer/" title="RocketMQ学习-四-consumer"><span>< PreviousPost</span><br><span class="prevTitle">RocketMQ学习-四-consumer</span></a><a class="nextSlogan" href="/2018/08/25/RocketMQ%E5%AD%A6%E4%B9%A0-%E4%B8%89-producer/" title="RocketMQ学习(三) producer"><span>NextPost ></span><br><span class="nextTitle">RocketMQ学习(三) producer</span></a><div class="clear"></div></div><div id="comment"><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: 'RocketMQ学习(二) broker',
  owner: '9928627',
  repo: 'zsfblues.github.io',
  oauth: {
    client_id: '27ef90191eda06aadd5b',
    client_secret: 'f2ed675c18da0938f480e4eef3cf44d480f6d801',
  },
})
gitment.render('container')</script></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo" target="_blank" rel="noopener"><span>Cxo</span></a></p></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#消息持久化"><span class="toc-number">1.</span> <span class="toc-text">消息持久化</span></a></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>