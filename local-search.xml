<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浅谈Redis中的内存优化设计</title>
    <link href="/2020/05/08/%E6%B5%85%E8%B0%88Redis%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/05/08/%E6%B5%85%E8%B0%88Redis%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>Redis作为一个高效的kv型键值型数据库，除了依赖内存高效处理读写操作外，在节约内存的设计上也有着近乎于苛刻，总是想尽一切办法来节约内存，本次主要结合两个比较典型的数据结构上的设计来一窥Redis中的内存优化之道：sds和ziplist。</p><hr><p>在介绍这两个数据结构之前，我们先聊一下基础数据结构：robj。</p><p>从Redis的使用者的角度来看，一个Redis节点包含多个db（非cluster模式下默认是16个，cluster模式下只能是1个），而一个db就是维护了从key 到value的映射关系。key只能是string类型，而value可以是多种数据类型，比如：string，list，hash，zset，set等。</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="hljs-comment">/* Raw representation */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="hljs-comment">/* Encoded as integer */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="hljs-comment">/* Encoded as hash table */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="hljs-comment">/* 已废弃 */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="hljs-comment">/* 已废弃 */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="hljs-comment">/* Encoded as ziplist */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="hljs-comment">/* Encoded as intset */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="hljs-comment">/* Encoded as skiplist */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="hljs-comment">/* Embedded sds string encoding */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="hljs-comment">/* Encoded as linked list of ziplists */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="hljs-comment">/* Encoded as a radix tree of listpacks */</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span>    <span class="hljs-keyword">unsigned</span> type:<span class="hljs-number">4</span>;    <span class="hljs-keyword">unsigned</span> encoding:<span class="hljs-number">4</span>;    <span class="hljs-keyword">unsigned</span> lru:LRU_BITS; <span class="hljs-comment">/* LRU time (relative to global lru_clock) or</span><span class="hljs-comment">                            * LFU data (least significant 8 bits frequency</span><span class="hljs-comment">                            * and most significant 16 bits access time). */</span>    <span class="hljs-keyword">int</span> refcount;    <span class="hljs-keyword">void</span> *ptr;&#125; robj;</code></pre><ul><li><p>type：value的类型字段，占用4bit(总计表达16种)，目前就有以下几种</p><ul><li><pre><code class="c"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STRING 0    <span class="comment">/* String object. */</span></span><span class="meta">#<span class="meta-keyword">define</span> OBJ_LIST 1      <span class="comment">/* List object. */</span></span><span class="meta">#<span class="meta-keyword">define</span> OBJ_SET 2       <span class="comment">/* Set object. */</span></span><span class="meta">#<span class="meta-keyword">define</span> OBJ_ZSET 3      <span class="comment">/* Sorted set object. */</span></span><span class="meta">#<span class="meta-keyword">define</span> OBJ_HASH 4      <span class="comment">/* Hash object. */</span></span><span class="meta">#<span class="meta-keyword">define</span> OBJ_MODULE 5    <span class="comment">/* Module object. Redis4.0引进了可插拔的模块来扩展功能，这种类型的对象标明是由模块直接管理*/</span></span><span class="meta">#<span class="meta-keyword">define</span> OBJ_STREAM 6    <span class="comment">/* Stream object. */</span></span>&lt;!--￼<span class="number">1</span>--&gt;</code></pre></li></ul></li></ul><p>其中除了SDS_TYPE_5这种类型没有alloc和len字段外，其它类型都会包含，而对于SDS_TYPE_5这种类型，主要用于存储不超过32字节的字符串(5bit最大值)，在最低的3bit上用于存储flags类型信息，高5bit用户存储字符长度，不过在具体的使用上，由于这种类型扩展性不好，并不会使用这种类型进行存储，但判定字符串大于小于32字节时会自动转换为SDS_TYPE_8类型。</p><p>sds的类型结构如下：</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr5</span> &#123;</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> flags;     <span class="hljs-keyword">char</span> buf[];&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr8</span> &#123;</span>    <span class="hljs-keyword">uint8_t</span> len;     <span class="hljs-keyword">uint8_t</span> alloc;     <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> flags;    <span class="hljs-keyword">char</span> buf[];&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr16</span> &#123;</span>    <span class="hljs-keyword">uint16_t</span> len;     <span class="hljs-keyword">uint16_t</span> alloc;     <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> flags;     <span class="hljs-keyword">char</span> buf[];&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr32</span> &#123;</span>    <span class="hljs-keyword">uint32_t</span> len;    <span class="hljs-keyword">uint32_t</span> alloc;    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> flags;     <span class="hljs-keyword">char</span> buf[];&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr64</span> &#123;</span>    <span class="hljs-keyword">uint64_t</span> len;     <span class="hljs-keyword">uint64_t</span> alloc;     <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> flags;     <span class="hljs-keyword">char</span> buf[];&#125;;</code></pre><p>len：表示当前存储字符串已消耗的字节大小</p><p>alloc：总共分配的内存大小(不包含header大小以及NULL结束符所占用的大小)</p><p>flags：sds的类型信息，用低3bit标识</p><p><strong>__attribute__((__packed__))</strong>这个在C语言中是为了让编译器以紧凑模式来分配内存，默认情况下编译器可能会为struct的字段做优化对齐，在其中填充空字节。这样一来在内存分配上就不会连续，后续会看到Redis在获取sds的flags字段信息时是通过header的大小向低位偏移一个字节获取的。</p><p>在robj为string类型时总共有三种不同encoding，其中OBJ_ENCODING_RAW和OBJ_ENCODING_EMBSTR都是由sds来表示，在object.c的文件中有一个用于创建EMBSTR类型的对象方法：</p><pre><code class="hljs c"><span class="hljs-function">robj *<span class="hljs-title">createEmbeddedStringObject</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *ptr, <span class="hljs-keyword">size_t</span> len)</span> </span>&#123;    robj *o = zmalloc(<span class="hljs-keyword">sizeof</span>(robj)+<span class="hljs-keyword">sizeof</span>(struct sdshdr8)+len+<span class="hljs-number">1</span>);    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr8</span> *<span class="hljs-title">sh</span> = (<span class="hljs-title">void</span>*)(<span class="hljs-title">o</span>+1);</span> <span class="hljs-comment">//内存连续，所以这里的1要理解为sizeof(robj)，即指针指向sdshdr</span>    o-&gt;type = OBJ_STRING;    o-&gt;encoding = OBJ_ENCODING_EMBSTR;    o-&gt;ptr = sh+<span class="hljs-number">1</span>; <span class="hljs-comment">// sh+1 实际上是 sh + sizeof(struct sdshdr8)，指向buf</span>    o-&gt;refcount = <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="hljs-number">8</span>) | LFU_INIT_VAL;    &#125; <span class="hljs-keyword">else</span> &#123;        o-&gt;lru = LRU_CLOCK();    &#125;    sh-&gt;len = len;    sh-&gt;alloc = len;    sh-&gt;flags = SDS_TYPE_8;    <span class="hljs-keyword">if</span> (ptr == SDS_NOINIT)        sh-&gt;buf[len] = <span class="hljs-string">'\0'</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ptr) &#123;        <span class="hljs-built_in">memcpy</span>(sh-&gt;buf,ptr,len);        sh-&gt;buf[len] = <span class="hljs-string">'\0'</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">memset</span>(sh-&gt;buf,<span class="hljs-number">0</span>,len+<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> o;&#125;</code></pre><p>将robj和sds放在一个连续的内存块中分配，这样对于短字符串的存储有利于减少内存碎片，由以下部分组成</p><ul><li>16个字节的robj结构</li></ul><ul><li>3个字节的sdshdr8头</li><li>最多44个字节的sds字符数组</li><li>1个NULL结束符</li></ul><p>16 + 3 + 44 + 1=64，正好符合一些内存分配器(例如jemalloc)一次性能分配的最大连续内存大小，因而在设计上符合</p><img src="https://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/robj_embstr_sds.png" srcset="/img/loading.gif" width="314" height="300" /><h4 id="设计上的缺点"><a href="#设计上的缺点" class="headerlink" title="设计上的缺点"></a>设计上的缺点</h4><p>SDS虽然支持原生C字符串并且支持动态扩容，但仍有以下两个主要缺点</p><ol><li>很多操作(向字符串追加)需要创建新的SDS对象，这会导致更大的内存分配</li><li>由于SDS支持对象共享，意味着修改字符串时需要顾及所有引用他的地方</li></ol><h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><p>ziplist在官方上定义为一个拥有特殊编码的内存紧凑型双向列表。</p><p>ziplist在设计上节省内存的表现：</p><ol><li><p>双端list，为了向前遍历节点，不使用指针链接的方式(避免内存碎片导致内存浪费)，在内存分配上物理相邻，在每一个节点(entry)直接记录上一个节点的长度(prevrawlen),同步通过prevrawlensize标明上一个的节点编码大小，相比较于传统的指针遍历的方式，节省了指针占用内存较高的问题(依赖于系统版本，在64位系统上需要8个字节)</p></li><li><p>zlentry中encoding字段的存储设计，从大的方面说，encoding字段代表两种编码类型(int和string)，从小的方面看，在两大类型基础上，又将string分为(1,2,5bytes)三种小类型，int分为(1,2,3,4,8bytes)五种小类型</p></li></ol><p><zlbytes> <zltail> <zllen> <entry> <entry> <entry> <zlend></p><p>zlbytes：占用4个字节，用于标识ziplist占用的总内存大小</p><p>zltail：占用4个字节标识最后一个entry的内存偏移量，方便进行类似pop之类需要在尾部执行的操作</p><p>zllen：占用2个字节，标识ziplist拥有entry个数</p><p>zlend：占用1个字节，ziplist的结束标识，使用固定值255</p><p>因此一个空的压缩列表由总字节长度(4字节)，尾节点偏移量(4字节)，节点数量(2字节)，以及值为255的特殊结束符(1字节)组成。</p><p>重点是要谈一谈entry的设计：</p><p><prevlen> <encoding> <entry-data></p><p>prevlen：用来存储前一个entry的长度，这样可以通过减去这个值快速从后向前进行遍历</p><p>encoding：当前entry的编码方式，包含字符串(3种)和数字类型(5种)</p><p>entry-data：保存entry的内容，在encoding为数字型时存在一种情况会被省略</p><hr><h4 id="字符串类型设计"><a href="#字符串类型设计" class="headerlink" title="字符串类型设计"></a>字符串类型设计</h4><table><thead><tr><th>encoding格式</th><th>占用长度</th><th>存储范围</th></tr></thead><tbody><tr><td>00xxxxxx</td><td>1字节</td><td>&lt;=63字节(6bit)</td></tr><tr><td>01xxxxxx|aaaaaaaa|</td><td>2个字节</td><td>&lt;=16383个字节(14bit)</td></tr><tr><td>10000000|aaaaaaaa|bbbbbbbb|cccccccc|dddddddd|</td><td>5个字节</td><td>&lt;=4294967295个字节(32bit)</td></tr></tbody></table><h4 id="数字类型设计"><a href="#数字类型设计" class="headerlink" title="数字类型设计"></a>数字类型设计</h4><table><thead><tr><th>encoding格式</th><th>占用长度</th><th>存储范围</th></tr></thead><tbody><tr><td>11111110(0xFE)</td><td>1个字节</td><td>-128-127的整数存储</td></tr><tr><td>11000000(0xc0 | 0&lt;&lt;4)</td><td>1个字节</td><td>16bit存储(-2^15^ - (2^15^ -1))</td></tr><tr><td>11110000(0xc0 | 3&lt;&lt;4)</td><td>1个字节</td><td>24bit存储(-2^23^ - (2^23^ -1))</td></tr><tr><td>11010000(0xc0 | 1&lt;&lt;4)</td><td>1个字节</td><td>32bit存储(-2^31^ - (2^31^ -1))</td></tr><tr><td>11100000(0xc0 | 2&lt;&lt;4)</td><td>1个字节</td><td>64bit存储(-2^63^ - (2^63^ -1))</td></tr><tr><td>11110001 - 1111101</td><td>1个字节</td><td>表示0 -12的整数</td></tr></tbody></table><p>其中最后一种情况是整数型存储的一种特殊情况，在这类型中，entry-data的部分会被省略，和encoding字段合二为一。</p><p>接下来以一个具体事例来讲解ziplist存储情况:</p><img src="https://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/ziplist_exp.png" srcset="/img/loading.gif" style="zoom70%;" /><p>从这个例子中：</p><ol><li>entry1是一个字符串编码的节点类型，由于是第一个entry，所以prerawlen是0，占用1byte，内容是”xuanlin”共7个字符，占用7bytes，将ASCII码转成16进制就为encoding-data的内容，由于在63bytes以内，所以类型为ZIP_STR_06B(00xxxxxx)</li><li>entry2是一个整数类型编码的节点类型，由于前一个entry总共占用9(1+1+7)个bytes，所以prerawlen是9，占用1byte，内容是”10”，介于0-12之间，所以为11111011，占用1byte，总共占用2bytes</li></ol><p>因此ziplist的整体长度就是4+4+2+9+2+1=22个字节，按照大端字节序存储就是0x16(<a href="https://www.ruanyifeng.com/blog/2016/11/byte-order.html" target="_blank" rel="noopener">关于字节序的类型说明</a> )，ztail就是(22-3=19)为0x13，</p><p>接下来以插入代码来讲解一下ziplist的工作流程(省略了一下内存拷贝的操作，无关主流程)：</p><pre><code class="hljs c"><span class="hljs-comment">/* Insert item at "p". */</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *__ziplistInsert(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *zl, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *p, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *s, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> slen) &#123;    <span class="hljs-keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> prevlensize, prevlen = <span class="hljs-number">0</span>;    <span class="hljs-keyword">size_t</span> offset;    <span class="hljs-keyword">int</span> nextdiff = <span class="hljs-number">0</span>;    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> encoding = <span class="hljs-number">0</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> value = <span class="hljs-number">123456789</span>;     zlentry tail;    <span class="hljs-comment">/* 获取前一个节点的长度 */</span>    <span class="hljs-keyword">if</span> (p[<span class="hljs-number">0</span>] != ZIP_END) &#123;        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);        <span class="hljs-keyword">if</span> (ptail[<span class="hljs-number">0</span>] != ZIP_END) &#123;            prevlen = zipRawEntryLength(ptail);        &#125;    &#125;    <span class="hljs-comment">/* 尝试将待插入节点按照数字编码 */</span>    <span class="hljs-keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;        <span class="hljs-comment">/* 获取存储数字的大小 */</span>        reqlen = zipIntSize(encoding);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">/* 失败则按字符串编码，以字符串长度获取存储大小*/</span>        reqlen = slen;    &#125;    <span class="hljs-comment">/* 计算待插入节点的prerawsize大小 */</span>    reqlen += zipStorePrevEntryLength(<span class="hljs-literal">NULL</span>,prevlen);    <span class="hljs-comment">/* 计算待插入节点的lensize */</span>    reqlen += zipStoreEntryEncoding(<span class="hljs-literal">NULL</span>,encoding,slen);    <span class="hljs-comment">/* 计算待插入节点与原节点的字节差 */</span>    nextdiff = (p[<span class="hljs-number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="hljs-number">0</span>;    <span class="hljs-comment">/* 因为插入节点采用的copyOnWrite的策略，因此地址会变化，需要该插入位置的内存偏移量 */</span>    offset = p-zl;    zl = ziplistResize(zl,curlen+reqlen+nextdiff);    p = zl+offset;    <span class="hljs-keyword">if</span> (nextdiff != <span class="hljs-number">0</span>) &#123;        offset = p-zl;      <span class="hljs-comment">/* 判断是否级联更新 */</span>        zl = __ziplistCascadeUpdate(zl,p+reqlen);        p = zl+offset;    &#125;    <span class="hljs-keyword">return</span> zl;&#125;</code></pre><p>从整个流程的前半部分来看，在插入一个新节点时，也需要计算<strong><prevlen> <encoding> <entry-data></strong>三个部分的大小</p><ol><li>ZIP_DECODE_PREVLEN和zipRawEntryLength就是获取上一个节点的大小，后续通过zipStorePrevEntryLength求得编码之后的大小</li><li>通过判断插入节点的类型(字符串还是整数)获取entry-data的字节数</li><li>zipStoreEntryEncoding求得该节点的内容长度，并将长度编码存储在encoding部分(encoding的部分主要包含字符串类型和数字类型的类型信息)</li></ol><h4 id="级联更新"><a href="#级联更新" class="headerlink" title="级联更新"></a>级联更新</h4><p>在ziplist的设计上，通过prevlen存储上一个节点的字节大小可以通过通减去该值同时依赖于内存连续分配从而快速向前遍历，省去很多指针开销，但在上述插入场景中，如果待插入节点的字节大小过大，导致其后续节点的字节的prevlen值无法在1个字节内存储，那么就会导致后续节点的内存需再分配，然后最差情况就像多米诺骨牌效应一样，导致后续所有节点的内存都需要再分配。</p><p><img src="https://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/ziplist_cascade_update.png?x-oss-process=style/zsfimage" srcset="/img/loading.gif" alt=""></p><p>插入的节点本身大小占用251bytes，加上两个字节的长度编码以及1byte的前一个节点的长度，后一个节点需要表示254bytes的prevlen，超出1个字节，导致后续内存再分配，如果zentry3本身大小也在250-253bytes之间的话，按照之前的计算规则，则继续上述操作，导致大量的内存拷贝，消耗CPU。这也是ziplist设计上的缺点。</p><p>从上述情况看，要想产生最坏情况下的级联更新的前期条件：待插入节点大小介入250-253bytes之间，包括后续节点也是介入这个之间。概率不大，并且即使产生这种情况，只要节点数量不多的话，还是没有太大的关系。但是Redis还是不想寄希望于不可控的”运气”，在5.0的版本中引入了listpack(紧凑列表)这种数据结构来希望后续替换ziplist，在listpack中每个节点只存自己的字节大小。存在在节点的尾部，这样直接通过总大小减去尾部的节点大小算出最后一个节点的偏移量。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综上来看，Redis的内存优化上有以下几个特点：</p><ol><li>数字类型优先，对于内容为数字的value，会将其转换为数字存储</li><li>内存分配尽量保证连续，这样可以避免内存碎片，同时节省指针的内存消耗</li><li>对于同一个数据结构，存在多种编码方式，在能存储内容地情况下，尽量选择内存占用更优的编码方式</li></ol>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ学习-四-consumer</title>
    <link href="/2019/02/17/RocketMQ%E5%AD%A6%E4%B9%A0-%E5%9B%9B-consumer/"/>
    <url>/2019/02/17/RocketMQ%E5%AD%A6%E4%B9%A0-%E5%9B%9B-consumer/</url>
    
    <content type="html"><![CDATA[<hr><p>​    作为消息中间件的重要组成部分，消费者的作用的主要在于下游接收producer产生的消息数据，以便在业务系统中处理相应的逻辑。</p><p>它的整个消费流程借用某位大牛的图片：</p><p><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/006HiYd9ly1g0goksd761j31ly0wedwi.jpg" srcset="/img/loading.gif" alt="consumer消费流程图"></p><p>​    消息的消费模型一般说来有两种：推模型(Push)和拉模型(Pull)，不过这两种常规的模型都有着一些问题，push模型一般由消息的推送者在发出新消息后主动对下游的消费者进行推送，如果推送的速率过快导致消费方消费不过来(比如下游有一些IO操作，或者请求三方服务的操作相对耗时)就会导致消费方负载过高，这时候推送方又不能及时了解下游消费方的状态(实现这点往往又会增加推送方的复杂度)，有可能会导致下游宕机。而传统的pull模型如果希望有较好的实时性的话，就需要不断轮询推送方以便获取最新的消息，这样又会导致推送方负载过高。在这两种传统模型都存在明显缺点情况下，RocketMQ(以下简称rmq)在实现消息消费时采用是一种<strong>长轮询</strong>，来平衡 Pull/Push 模型各自的缺点，基本方式是：消费方如果尝试拉取失败，并不会立即返回响应结果(但也会设置超时等待时间)，而是把请求挂在那里 wait(也可以理解为保存在服务方那边)，如果有新的消息到来，把请求拉起，返回最新消息。</p><hr><h3 id="一-消费者启动"><a href="#一-消费者启动" class="headerlink" title="一. 消费者启动"></a>一. 消费者启动</h3><p>​    rmq消费也实现了push和pull模型，不过push也是实现了长轮询的一种pull，因为push对业务方实现较为简单，也是大部分情况下首选的消费模型，所以这里以push模型来讲，可以以官方demo来切入。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, MQClientException </span>&#123;        DefaultMQPushConsumer consumer = <span class="hljs-keyword">new</span> DefaultMQPushConsumer(<span class="hljs-string">"test-consumer-group"</span>);        consumer.setNamesrvAddr(<span class="hljs-string">"127.0.0.1:9876;"</span>);            consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);        consumer.subscribe(<span class="hljs-string">"TopicTest"</span>, <span class="hljs-string">"*"</span>);        consumer.registerMessageListener(<span class="hljs-keyword">new</span> MessageListenerConcurrently() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs,</span></span><span class="hljs-function"><span class="hljs-params">                ConsumeConcurrentlyContext context)</span> </span>&#123;                System.out.printf(<span class="hljs-string">"%s Receive New Messages: %s %n"</span>, Thread.currentThread().getName(), msgs);                <span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;            &#125;        &#125;);        consumer.start();        System.out.printf(<span class="hljs-string">"Consumer Started.%n"</span>);    &#125;&#125;</code></pre><p>​    可以看见消费方实例化一个消费者实例，确定好需要订阅的topic和tag，并指定好namesrv地址。messageListener则是一个监听回调类，用于收到消息后处理相应的业务逻辑。最为关键的步骤在于start方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MQClientException </span>&#123;        <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.serviceState) &#123;            <span class="hljs-keyword">case</span> CREATE_JUST:                log.info(<span class="hljs-string">"the consumer [&#123;&#125;] start beginning. messageModel=&#123;&#125;, isUnitMode=&#123;&#125;"</span>, <span class="hljs-keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(),                    <span class="hljs-keyword">this</span>.defaultMQPushConsumer.getMessageModel(), <span class="hljs-keyword">this</span>.defaultMQPushConsumer.isUnitMode());                <span class="hljs-keyword">this</span>.serviceState = ServiceState.START_FAILED;                <span class="hljs-keyword">this</span>.checkConfig();                <span class="hljs-keyword">this</span>.copySubscription();                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) &#123;                    <span class="hljs-keyword">this</span>.defaultMQPushConsumer.changeInstanceNameToPID();                &#125;                <span class="hljs-comment">// 这里是和消费方绑定的一个客户端实例，后续通过它来启动多个后台任务，也可作为producer的客户端实例对象</span>                <span class="hljs-keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="hljs-keyword">this</span>.defaultMQPushConsumer, <span class="hljs-keyword">this</span>.rpcHook);                <span class="hljs-keyword">this</span>.rebalanceImpl.setConsumerGroup(<span class="hljs-keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());                <span class="hljs-keyword">this</span>.rebalanceImpl.setMessageModel(<span class="hljs-keyword">this</span>.defaultMQPushConsumer.getMessageModel());                <span class="hljs-keyword">this</span>.rebalanceImpl.setAllocateMessageQueueStrategy(<span class="hljs-keyword">this</span>.defaultMQPushConsumer.getAllocateMessageQueueStrategy());                <span class="hljs-keyword">this</span>.rebalanceImpl.setmQClientFactory(<span class="hljs-keyword">this</span>.mQClientFactory);                <span class="hljs-keyword">this</span>.pullAPIWrapper = <span class="hljs-keyword">new</span> PullAPIWrapper(                    mQClientFactory,                    <span class="hljs-keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());                <span class="hljs-keyword">this</span>.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.defaultMQPushConsumer.getOffsetStore() != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">this</span>.offsetStore = <span class="hljs-keyword">this</span>.defaultMQPushConsumer.getOffsetStore();                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;                        <span class="hljs-keyword">case</span> BROADCASTING:                            <span class="hljs-keyword">this</span>.offsetStore = <span class="hljs-keyword">new</span> LocalFileOffsetStore(<span class="hljs-keyword">this</span>.mQClientFactory, <span class="hljs-keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());                            <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">case</span> CLUSTERING:                            <span class="hljs-keyword">this</span>.offsetStore = <span class="hljs-keyword">new</span> RemoteBrokerOffsetStore(<span class="hljs-keyword">this</span>.mQClientFactory, <span class="hljs-keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());                            <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">default</span>:                            <span class="hljs-keyword">break</span>;                    &#125;                    <span class="hljs-keyword">this</span>.defaultMQPushConsumer.setOffsetStore(<span class="hljs-keyword">this</span>.offsetStore);                &#125;                <span class="hljs-keyword">this</span>.offsetStore.load();                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getMessageListenerInner() <span class="hljs-keyword">instanceof</span> MessageListenerOrderly) &#123;                    <span class="hljs-keyword">this</span>.consumeOrderly = <span class="hljs-keyword">true</span>;                    <span class="hljs-keyword">this</span>.consumeMessageService =                        <span class="hljs-keyword">new</span> ConsumeMessageOrderlyService(<span class="hljs-keyword">this</span>, (MessageListenerOrderly) <span class="hljs-keyword">this</span>.getMessageListenerInner());                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getMessageListenerInner() <span class="hljs-keyword">instanceof</span> MessageListenerConcurrently) &#123;                    <span class="hljs-keyword">this</span>.consumeOrderly = <span class="hljs-keyword">false</span>;                    <span class="hljs-keyword">this</span>.consumeMessageService =                        <span class="hljs-keyword">new</span> ConsumeMessageConcurrentlyService(<span class="hljs-keyword">this</span>, (MessageListenerConcurrently) <span class="hljs-keyword">this</span>.getMessageListenerInner());                &#125;                <span class="hljs-comment">// 清除过期消息</span>                <span class="hljs-keyword">this</span>.consumeMessageService.start();                <span class="hljs-keyword">boolean</span> registerOK = mQClientFactory.registerConsumer(<span class="hljs-keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="hljs-keyword">this</span>);                <span class="hljs-keyword">if</span> (!registerOK) &#123;                    <span class="hljs-keyword">this</span>.serviceState = ServiceState.CREATE_JUST;                    <span class="hljs-keyword">this</span>.consumeMessageService.shutdown();                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MQClientException(<span class="hljs-string">"The consumer group["</span> + <span class="hljs-keyword">this</span>.defaultMQPushConsumer.getConsumerGroup()                        + <span class="hljs-string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),                        <span class="hljs-keyword">null</span>);                &#125;<span class="hljs-comment">// 重点关注方法</span>                mQClientFactory.start();                log.info(<span class="hljs-string">"the consumer [&#123;&#125;] start OK."</span>, <span class="hljs-keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());                <span class="hljs-keyword">this</span>.serviceState = ServiceState.RUNNING;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> RUNNING:            <span class="hljs-keyword">case</span> START_FAILED:            <span class="hljs-keyword">case</span> SHUTDOWN_ALREADY:                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MQClientException(<span class="hljs-string">"The PushConsumer service state not OK, maybe started once, "</span>                    + <span class="hljs-keyword">this</span>.serviceState                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),                    <span class="hljs-keyword">null</span>);            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">this</span>.updateTopicSubscribeInfoWhenSubscriptionChanged();        <span class="hljs-keyword">this</span>.mQClientFactory.checkClientInBroker();        <span class="hljs-keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();        <span class="hljs-keyword">this</span>.mQClientFactory.rebalanceImmediately();    &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MQClientException </span>&#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.serviceState) &#123;                <span class="hljs-keyword">case</span> CREATE_JUST:                    <span class="hljs-keyword">this</span>.serviceState = ServiceState.START_FAILED;                                   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == <span class="hljs-keyword">this</span>.clientConfig.getNamesrvAddr()) &#123;                        <span class="hljs-keyword">this</span>.mQClientAPIImpl.fetchNameServerAddr();                    &#125;                                        <span class="hljs-keyword">this</span>.mQClientAPIImpl.start();                    <span class="hljs-comment">// 包含定时获取namesrv地址，更新topic路由信息，去除下线的broker信息，保存消费状态等定时任务</span>                    <span class="hljs-keyword">this</span>.startScheduledTask();                    <span class="hljs-comment">// 拉取消息任务</span>                    <span class="hljs-keyword">this</span>.pullMessageService.start();                    <span class="hljs-comment">// 消费方的负载均衡，主要给消费者分配topic队列信息</span>                    <span class="hljs-keyword">this</span>.rebalanceService.start();                    <span class="hljs-comment">// 这是面向producer端的</span>                    <span class="hljs-keyword">this</span>.defaultMQProducer.getDefaultMQProducerImpl().start(<span class="hljs-keyword">false</span>);                    log.info(<span class="hljs-string">"the client factory [&#123;&#125;] start OK"</span>, <span class="hljs-keyword">this</span>.clientId);                    <span class="hljs-keyword">this</span>.serviceState = ServiceState.RUNNING;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> RUNNING:                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> SHUTDOWN_ALREADY:                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> START_FAILED:                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MQClientException(<span class="hljs-string">"The Factory object["</span> + <span class="hljs-keyword">this</span>.getClientId() + <span class="hljs-string">"] has been created before, and failed."</span>, <span class="hljs-keyword">null</span>);                <span class="hljs-keyword">default</span>:                    <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;</code></pre><h3 id="二-消费方的负载均衡"><a href="#二-消费方的负载均衡" class="headerlink" title="二. 消费方的负载均衡"></a>二. 消费方的负载均衡</h3><p>​    在启动rebalanceService服务后，默认会以20s为一个周期来调整消费者和topic队列的对应关系，以便在队列信息发生变更和一个消费组中加入(移除)消费方进行调整:</p><p><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/mw690/006HiYd9ly1g0gsykgq8fj30xg0e80wr.jpg" srcset="/img/loading.gif" alt=""></p><p>我们这里以集群模式下的消费来讲：</p><pre><code class="hljs java">               <span class="hljs-comment">// 获取一个topic下的所有队列</span>               Set&lt;MessageQueue&gt; mqSet = <span class="hljs-keyword">this</span>.topicSubscribeInfoTable.get(topic);               <span class="hljs-comment">// 获取订阅某topic下某个消费组的所有实例id</span>               List&lt;String&gt; cidAll = <span class="hljs-keyword">this</span>.mQClientFactory.findConsumerIdList(topic, consumerGroup);               <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == mqSet) &#123;                   <span class="hljs-keyword">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;                       log.warn(<span class="hljs-string">"doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist."</span>, consumerGroup, topic);                   &#125;               &#125;               <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == cidAll) &#123;                   log.warn(<span class="hljs-string">"doRebalance, &#123;&#125; &#123;&#125;, get consumer id list failed"</span>, consumerGroup, topic);               &#125;               <span class="hljs-keyword">if</span> (mqSet != <span class="hljs-keyword">null</span> &amp;&amp; cidAll != <span class="hljs-keyword">null</span>) &#123;                   List&lt;MessageQueue&gt; mqAll = <span class="hljs-keyword">new</span> ArrayList&lt;MessageQueue&gt;();                   mqAll.addAll(mqSet);                   Collections.sort(mqAll);                   Collections.sort(cidAll);                   <span class="hljs-comment">// 获取消费端的负载均衡策略，默认是均分模式，即尽量让同一个消费组下的消费组平分messageQueue</span>                   AllocateMessageQueueStrategy strategy = <span class="hljs-keyword">this</span>.allocateMessageQueueStrategy;                   List&lt;MessageQueue&gt; allocateResult = <span class="hljs-keyword">null</span>;                   <span class="hljs-keyword">try</span> &#123;                       allocateResult = strategy.allocate(                           <span class="hljs-keyword">this</span>.consumerGroup,                           <span class="hljs-keyword">this</span>.mQClientFactory.getClientId(),                           mqAll,                           cidAll);                   &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;                       log.error(<span class="hljs-string">"AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName=&#123;&#125;"</span>, strategy.getName(),                           e);                       <span class="hljs-keyword">return</span>;                   &#125;                   Set&lt;MessageQueue&gt; allocateResultSet = <span class="hljs-keyword">new</span> HashSet&lt;MessageQueue&gt;();                   <span class="hljs-keyword">if</span> (allocateResult != <span class="hljs-keyword">null</span>) &#123;                       allocateResultSet.addAll(allocateResult);                   &#125;                   <span class="hljs-comment">// 这里进行检测之前的分配关系是否发生变化(刚启动时必然是变化的)</span>                   <span class="hljs-keyword">boolean</span> changed = <span class="hljs-keyword">this</span>.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);                   <span class="hljs-keyword">if</span> (changed) &#123;                       log.info(                           <span class="hljs-string">"rebalanced result changed. allocateMessageQueueStrategyName=&#123;&#125;, group=&#123;&#125;, topic=&#123;&#125;, clientId=&#123;&#125;, mqAllSize=&#123;&#125;, cidAllSize=&#123;&#125;, rebalanceResultSize=&#123;&#125;, rebalanceResultSet=&#123;&#125;"</span>,                           strategy.getName(), consumerGroup, topic, <span class="hljs-keyword">this</span>.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(),                           allocateResultSet.size(), allocateResultSet);                       <span class="hljs-keyword">this</span>.messageQueueChanged(topic, mqSet, allocateResultSet);                   &#125;               &#125;               <span class="hljs-keyword">break</span>;           &#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">updateProcessQueueTableInRebalance</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String topic, <span class="hljs-keyword">final</span> Set&lt;MessageQueue&gt; mqSet, <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isOrder)</span> </span>&#123;    ... 省略若干步骤       List&lt;PullRequest&gt; pullRequestList = <span class="hljs-keyword">new</span> ArrayList&lt;PullRequest&gt;();       <span class="hljs-keyword">for</span> (MessageQueue mq : mqSet) &#123;           <span class="hljs-comment">// 将新增的队列加入到processQueueTable中来</span>           <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.processQueueTable.containsKey(mq)) &#123;               <span class="hljs-keyword">if</span> (isOrder &amp;&amp; !<span class="hljs-keyword">this</span>.lock(mq)) &#123;                   log.warn(<span class="hljs-string">"doRebalance, &#123;&#125;, add a new mq failed, &#123;&#125;, because lock failed"</span>, consumerGroup, mq);                   <span class="hljs-keyword">continue</span>;               &#125;               <span class="hljs-keyword">this</span>.removeDirtyOffset(mq);               ProcessQueue pq = <span class="hljs-keyword">new</span> ProcessQueue();               <span class="hljs-keyword">long</span> nextOffset = <span class="hljs-keyword">this</span>.computePullFromWhere(mq);               <span class="hljs-keyword">if</span> (nextOffset &gt;= <span class="hljs-number">0</span>) &#123;                   ProcessQueue pre = <span class="hljs-keyword">this</span>.processQueueTable.putIfAbsent(mq, pq);                   <span class="hljs-keyword">if</span> (pre != <span class="hljs-keyword">null</span>) &#123;                       log.info(<span class="hljs-string">"doRebalance, &#123;&#125;, mq already exists, &#123;&#125;"</span>, consumerGroup, mq);                   &#125; <span class="hljs-keyword">else</span> &#123;                       log.info(<span class="hljs-string">"doRebalance, &#123;&#125;, add a new mq, &#123;&#125;"</span>, consumerGroup, mq);                       PullRequest pullRequest = <span class="hljs-keyword">new</span> PullRequest();                       pullRequest.setConsumerGroup(consumerGroup);                       pullRequest.setNextOffset(nextOffset);                       pullRequest.setMessageQueue(mq);                       pullRequest.setProcessQueue(pq);                       pullRequestList.add(pullRequest);                       changed = <span class="hljs-keyword">true</span>;                   &#125;               &#125; <span class="hljs-keyword">else</span> &#123;                   log.warn(<span class="hljs-string">"doRebalance, &#123;&#125;, add new mq failed, &#123;&#125;"</span>, consumerGroup, mq);               &#125;           &#125;           <span class="hljs-comment">// 这个结合第一张流程图来看，也是后续pullRequestQueue中的数据来源(即拉取消息任务)</span>           <span class="hljs-keyword">this</span>.dispatchPullRequest(pullRequestList);       &#125;</code></pre><p>​    在集群模式下获取订阅某topic下某个消费组的所有实例id以及该topic下的message queue集合在某一特定负载均衡策略下进行分配，其中processQueueTable维护的是一个消费组下对topic下某一队列的消费状况(因为是集群模式消费，所以所有消费组中的实例都会共享消费进度)，最终生成新的拉取消息的请求对象。由于是以topic为单位进行rebalance，最终一个queue就会生成一个pullRequest对象。通过<strong>Collections.sort(mqAll)</strong>和<strong>Collections.sort(cidAll)</strong>操作目的是后续topic队列信息和消费者实例数就算发生变化，也可以保证统一的数据排列方式和分配方式，比如第一个实例永远会对应第一个队列。</p><h3 id="三-消费方拉取消息"><a href="#三-消费方拉取消息" class="headerlink" title="三. 消费方拉取消息"></a>三. 消费方拉取消息</h3><p>​    consumer启动时也会同时启动后台任务来获取pullRequest对象来拉取任务，在pull消息，会带上几个比较重要的参数：</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> sysFlag = PullSysFlag.buildSysFlag(            commitOffsetEnable, <span class="hljs-comment">// commitOffset</span>            <span class="hljs-keyword">true</span>, <span class="hljs-comment">// suspend</span>            subExpression != <span class="hljs-keyword">null</span>,             classFilter         );  <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">this</span>.pullAPIWrapper.pullKernelImpl(                pullRequest.getMessageQueue(), <span class="hljs-comment">// 向哪个队列信息消息拉取，queue &lt;-&gt; pullRequest</span>                subExpression, <span class="hljs-comment">// tag订阅表达式</span>                subscriptionData.getExpressionType(), <span class="hljs-comment">// tag订阅类型，sql92以及"||"分隔形式</span>                subscriptionData.getSubVersion(),                pullRequest.getNextOffset(),  <span class="hljs-comment">// 队列消费起始偏移量，集群模式下同一个消费组共享消费进度</span>                <span class="hljs-keyword">this</span>.defaultMQPushConsumer.getPullBatchSize(), <span class="hljs-comment">// 一次处理的消息数，默认是1</span>                sysFlag, <span class="hljs-comment">// 这个根据上面的构建代码可以看出里面包含当当前request无法立即获取消息后是否被broker hold住请求</span>                commitOffsetValue, <span class="hljs-comment">// 消费完成后的确认偏移量</span>                BROKER_SUSPEND_MAX_TIME_MILLIS, <span class="hljs-comment">// 最大hold时间</span>                CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND,  <span class="hljs-comment">// 消费超时时间</span>                CommunicationMode.ASYNC, <span class="hljs-comment">// 异步发送请求</span>                pullCallback  <span class="hljs-comment">// 获取响应的回调处理逻辑</span>            );        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            log.error(<span class="hljs-string">"pullKernelImpl exception"</span>, e);            <span class="hljs-keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);        &#125;</code></pre><p>最终消息的拉取是要通过netty发送请求到broker端来获取的</p><blockquote><p>RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, requestHeader);</p></blockquote><p>通过构建特定requestCode来进行消息拉取，说道requestCode，在broker刚刚启动时会在org.apache.rocketmq.broker.BrokerController#initialize中调用org.apache.rocketmq.broker.BrokerController#registerProcessor方法中注册若干个Processor到本地processorTable中，对应每一个requestCode，都有相应的线程池来处理请求。在netty端通过事件处理器来监听请求数据</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">RemotingCommand</span>&gt; </span>&#123;       <span class="hljs-meta">@Override</span>       <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, RemotingCommand msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;           processMessageReceived(ctx, msg);       &#125;   &#125;</code></pre><p>在拉取消息的PullMessageProcessor中进行消息的拉取，其中会做一些权限检查，tag和consumerGroup等参数合法性校验, 最终定位到</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> GetMessageResult getMessageResult =    <span class="hljs-keyword">this</span>.brokerController.getMessageStore().getMessage(requestHeader.getConsumerGroup(), requestHeader.getTopic(),        requestHeader.getQueueId(), requestHeader.getQueueOffset(), requestHeader.getMaxMsgNums(), messageFilter);</code></pre><p>在此处获取消息不管结果如何都会立即返回，真正的结果处理还是在PullMessageProcessor中，在获取拉取结果后，无非就是三大类：成功获取，拉取异常，消息未找到</p><ol><li><p>异常拉取</p><pre><code class="hljs java"><span class="hljs-comment">//  获取当前commitLog中的最大消息偏移量</span><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> maxOffsetPy = <span class="hljs-keyword">this</span>.commitLog.getMaxOffset();ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId);      <span class="hljs-keyword">if</span> (consumeQueue != <span class="hljs-keyword">null</span>) &#123;          <span class="hljs-comment">// 获取topic下某一个队列的最小和最大偏移量</span>          minOffset = consumeQueue.getMinOffsetInQueue();          maxOffset = consumeQueue.getMaxOffsetInQueue();             <span class="hljs-keyword">if</span> (maxOffset == <span class="hljs-number">0</span>) &#123;              status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;              nextBeginOffset = nextOffsetCorrection(offset, <span class="hljs-number">0</span>);          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (offset &lt; minOffset) &#123; <span class="hljs-comment">// offset表示之前pullRequest中的当前队列消费起始偏移量(一个消费进度)</span>              status = GetMessageStatus.OFFSET_TOO_SMALL;              nextBeginOffset = nextOffsetCorrection(offset, minOffset);          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (offset == maxOffset) &#123;              status = GetMessageStatus.OFFSET_OVERFLOW_ONE;              nextBeginOffset = nextOffsetCorrection(offset, offset);          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (offset &gt; maxOffset) &#123;              status = GetMessageStatus.OFFSET_OVERFLOW_BADLY;              <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == minOffset) &#123;                  nextBeginOffset = nextOffsetCorrection(offset, minOffset);              &#125; <span class="hljs-keyword">else</span> &#123;                  nextBeginOffset = nextOffsetCorrection(offset, maxOffset);              &#125;          &#125;      &#125;</code></pre><p>这些判断都在是在保证所传偏移量不会超出正常偏移量限制，对于logic offset，由于consumer queue的消息存储单元大小是20bytes，分别由8bytes的在commit log的offset，4bytes表示的消息大小和tag hashcode。其中第一个是可以映射commit log的实体消息的，tag hashcode用于过滤订阅消息的，minOffset和maxOffset就相当于queue offset大小，指向commit log中的位置。具体见下图：</p><p><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/006HiYd9ly1g0hhnpilt8j30pa0e2t9d.jpg" srcset="/img/loading.gif" alt="consumer queue结构图"></p></li></ol><p>由于consumer queue中的数据并不是对应commit log中相邻的消息体，所以拿到consumer queue后需要对其中的所有消息进行读取，</p><blockquote><pre><code class="hljs java"><span class="hljs-keyword">long</span> offsetPy = bufferConsumeQueue.getByteBuffer().getLong();<span class="hljs-keyword">int</span> sizePy = bufferConsumeQueue.getByteBuffer().getInt();<span class="hljs-keyword">long</span> tagsCode = bufferConsumeQueue.getByteBuffer().getLong();</code></pre></blockquote><p>这三块就对应consumer queue中消息单元的三个组成部分，表面上看上去似乎是一个随机读，但是由于命中page cache，效率上近似于顺序读最终通过获得offsetPy和sizePy就可以定位commit log中的消息。</p><p>对于暂时无法获取的消息，会走以下逻辑：</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (brokerAllowSuspend &amp;&amp; hasSuspendFlag) &#123;                    <span class="hljs-keyword">long</span> pollingTimeMills = suspendTimeoutMillisLong;                    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;                        pollingTimeMills = <span class="hljs-keyword">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills();                    &#125;                    String topic = requestHeader.getTopic();                    <span class="hljs-keyword">long</span> offset = requestHeader.getQueueOffset();                    <span class="hljs-keyword">int</span> queueId = requestHeader.getQueueId();                    PullRequest pullRequest = <span class="hljs-keyword">new</span> PullRequest(request, channel, pollingTimeMills,                        <span class="hljs-keyword">this</span>.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);                    <span class="hljs-keyword">this</span>.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);                    response = <span class="hljs-keyword">null</span>;                    <span class="hljs-keyword">break</span>;                &#125;</code></pre><p>​    通过之前consumer所传brokerAllowSuspend的参数判断是否先hold住此次请求，如果是的话就将这次请求放入pullRequestTable中, 等待有消息时获取通知。在broker启动后，同时会有一个reputMessageService线程一直在后台检测有没有新消息的到来。当有新数据产生时，reputMessageService本身维护一个reputFromOffset的偏移量(初始值为0)用以对比和 CommitLog 文件中的消息总偏移量的差距。当这两个偏移量不同的时候表示有新消息到来。会主动拉取pullRequestTable中的请求进行客户端通知。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCommitLogAvailable</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.reputFromOffset &lt; DefaultMessageStore.<span class="hljs-keyword">this</span>.commitLog.getMaxOffset();        &#125;</code></pre><p>​    另一方面，在PullRequestHoldService服务会主动轮询pullRequestTable的pullRequest对象，看在topic消息队列中是否有符合其要求的新消息产生，最终都是通过org.apache.rocketmq.broker.longpolling.PullRequestHoldService#notifyMessageArriving方法进行回调通知。</p><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (pullResult.getPullStatus()) &#123;                        <span class="hljs-keyword">case</span> FOUND:                            <span class="hljs-keyword">long</span> prevRequestOffset = pullRequest.getNextOffset();                            pullRequest.setNextOffset(pullResult.getNextBeginOffset());                            <span class="hljs-keyword">long</span> pullRT = System.currentTimeMillis() - beginTimestamp;                            DefaultMQPushConsumerImpl.<span class="hljs-keyword">this</span>.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),                                pullRequest.getMessageQueue().getTopic(), pullRT);                            <span class="hljs-keyword">long</span> firstMsgOffset = Long.MAX_VALUE;                            <span class="hljs-keyword">if</span> (pullResult.getMsgFoundList() == <span class="hljs-keyword">null</span> || pullResult.getMsgFoundList().isEmpty()) &#123;                                DefaultMQPushConsumerImpl.<span class="hljs-keyword">this</span>.executePullRequestImmediately(pullRequest);                            &#125; <span class="hljs-keyword">else</span> &#123;                                firstMsgOffset = pullResult.getMsgFoundList().get(<span class="hljs-number">0</span>).getQueueOffset();                                DefaultMQPushConsumerImpl.<span class="hljs-keyword">this</span>.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),                                    pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());                                <span class="hljs-keyword">boolean</span> dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());                                <span class="hljs-comment">// 将捞取到的消息封装成一个ConsumeRequest对象回传给consumer</span>                                DefaultMQPushConsumerImpl.<span class="hljs-keyword">this</span>.consumeMessageService.submitConsumeRequest(                                    pullResult.getMsgFoundList(),                                    processQueue,                                    pullRequest.getMessageQueue(),                                    dispatchToConsume);                                <span class="hljs-keyword">if</span> (DefaultMQPushConsumerImpl.<span class="hljs-keyword">this</span>.defaultMQPushConsumer.getPullInterval() &gt; <span class="hljs-number">0</span>) &#123;                                    DefaultMQPushConsumerImpl.<span class="hljs-keyword">this</span>.executePullRequestLater(pullRequest,                                        DefaultMQPushConsumerImpl.<span class="hljs-keyword">this</span>.defaultMQPushConsumer.getPullInterval());                                &#125; <span class="hljs-keyword">else</span> &#123;                                    DefaultMQPushConsumerImpl.<span class="hljs-keyword">this</span>.executePullRequestImmediately(pullRequest);                                &#125;                            &#125;                            <span class="hljs-keyword">if</span> (pullResult.getNextBeginOffset() &lt; prevRequestOffset                                || firstMsgOffset &lt; prevRequestOffset) &#123;                                log.warn(                                    <span class="hljs-string">"[BUG] pull message result maybe data wrong, nextBeginOffset: &#123;&#125; firstMsgOffset: &#123;&#125; prevRequestOffset: &#123;&#125;"</span>,                                    pullResult.getNextBeginOffset(),                                    firstMsgOffset,                                    prevRequestOffset);                            &#125;                            <span class="hljs-keyword">break</span>;</code></pre><p>​    在consumer接收到broker那边的回调通知后，将对应的结果封装成consumer request之中并保存在pullRequest的一个TreeMap之中(由于consumer端本身做了流控，所以不必担心大量消息请求结果会放在treeMap中以至撑爆内存，不过也需要注意下游消息的消费快慢问题)。</p><p>​    在消息成功到达之后，对于处理结果也有两种情况，消费成功(CONSUME_SUCCESS)以及稍后重试(RECONSUME_LATER)，并将处理结果上报给broker端。同时更新消费进度。</p><h3 id="四-消息重试"><a href="#四-消息重试" class="headerlink" title="四. 消息重试"></a>四. 消息重试</h3><p>​    在consumer启动时，它会将其订阅的topic使用org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl#copySubscription方法进行拷贝，同时在集群模式下会订阅一个特殊的重试topic，其构成是%RETRY% + 他所在的consumerGroup名，以便后续接收broker那边的消息。之前有说到不管消息处理的结果如何，都一定会将结果上报给broker端，那么重试状况下一样如此。对于消费后的状态返回，在返回值为null或抛出异常或返回RECONSUME_LATER时都会触发消息的重新消费，消费频率默认情况下是由broker端来进行控制(未配置情况下最大重试次数为16次)，整个流程如下图：</p><p><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/006HiYd9ly1g0ofwimxklj31no15ydsx.jpg" srcset="/img/loading.gif" alt="消息重试时序图"></p><p><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/006HiYd9ly1g0ogo5k6a4j318k12a13j.jpg" srcset="/img/loading.gif" alt="延时消息发送流程，借图"></p><p>​    在第一次进行重试时，它的延时级别会被置为3，这主要时避免消息重发过于频繁导致broker端的压力，每个延时级别都有对应的一个存储队列用来存储对应固定时延的(对应org.apache.rocketmq.store.schedule.ScheduleMessageService#delayLevelTable)，每一个队列抽象为一个个DeliverDelayedMessageTimerTask，在broker启动时，通过以下代码初始化：</p><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Long&gt; entry : <span class="hljs-keyword">this</span>.delayLevelTable.entrySet()) &#123;            Integer level = entry.getKey();            Long timeDelay = entry.getValue();            Long offset = <span class="hljs-keyword">this</span>.offsetTable.get(level);            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == offset) &#123;                offset = <span class="hljs-number">0L</span>;            &#125;            <span class="hljs-keyword">if</span> (timeDelay != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">this</span>.timer.schedule(<span class="hljs-keyword">new</span> DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME);            &#125;        &#125;</code></pre><p>刚开始的时候offset都为0，后续通过offset的变化寻找consumerQueue中的延时消息(offset可以看成consumerQueue中消息序号，从0开始，每次加一)。到时的延时消息通过重新put至commitLog中触发reputMessageService将消息重新取出进行投递。</p><h3 id="五-消息过滤"><a href="#五-消息过滤" class="headerlink" title="五. 消息过滤"></a>五. 消息过滤</h3><p>​    消息过滤的方式主要有基于tag以及sql92的方式，sql92具体参考<a href="https://en.wikipedia.org/wiki/SQL-92" target="_blank" rel="noopener">sql92维基百科</a>，这里主要以更常见的tag方式为例，当有到达时，在org.apache.rocketmq.broker.longpolling.PullRequestHoldService#notifyMessageArriving中会对消息与pullRequest中的请求信息进行对比。符合条件的才会回传给客户端</p><pre><code class="hljs java"> <span class="hljs-keyword">boolean</span> match = request.getMessageFilter().isMatchedByConsumeQueue(tagsCode,                            <span class="hljs-keyword">new</span> ConsumeQueueExt.CqExtUnit(tagsCode, msgStoreTime, filterBitMap));<span class="hljs-comment">// 可见比较的是tag的hashCode而不是名字</span><span class="hljs-keyword">return</span> subscriptionData.getSubString().equals(SubscriptionData.SUB_ALL)            || subscriptionData.getCodeSet().contains(tagsCode.intValue());</code></pre><p>在consumer启动时:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SubscriptionData <span class="hljs-title">buildSubscriptionData</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String consumerGroup, String topic,</span></span><span class="hljs-function"><span class="hljs-params">        String subString)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        SubscriptionData subscriptionData = <span class="hljs-keyword">new</span> SubscriptionData();        subscriptionData.setTopic(topic);        subscriptionData.setSubString(subString);        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == subString || subString.equals(SubscriptionData.SUB_ALL) || subString.length() == <span class="hljs-number">0</span>) &#123;            subscriptionData.setSubString(SubscriptionData.SUB_ALL);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 通过"||"进行tag拆分，然后将名称以及hashCode分别保存起来</span>            String[] tags = subString.split(<span class="hljs-string">"\\|\\|"</span>);            <span class="hljs-keyword">if</span> (tags.length &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">for</span> (String tag : tags) &#123;                    <span class="hljs-keyword">if</span> (tag.length() &gt; <span class="hljs-number">0</span>) &#123;                        String trimString = tag.trim();                        <span class="hljs-keyword">if</span> (trimString.length() &gt; <span class="hljs-number">0</span>) &#123;                            subscriptionData.getTagsSet().add(trimString);                            subscriptionData.getCodeSet().add(trimString.hashCode());                        &#125;                    &#125;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"subString split error"</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> subscriptionData;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息中间件</tag>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ学习(二) broker</title>
    <link href="/2018/11/25/RocketMQ%E5%AD%A6%E4%B9%A0-%E4%BA%8C-broker/"/>
    <url>/2018/11/25/RocketMQ%E5%AD%A6%E4%B9%A0-%E4%BA%8C-broker/</url>
    
    <content type="html"><![CDATA[<p>​    broker的启动和producer一样，启动时会同时启动多个定时任务，包括消息持久化，netty客户端启动，监听文件内容变更的等等…</p><hr><h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>消息持久化是broker最重要的任务，其稳定与否关系到消费者是否能消费到消息，整个mq是否会丢消息。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;       lock = lockFile.getChannel().tryLock(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">false</span>);       <span class="hljs-keyword">if</span> (lock == <span class="hljs-keyword">null</span> || lock.isShared() || !lock.isValid()) &#123;           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Lock failed,MQ already started"</span>);       &#125;       lockFile.getChannel().write(ByteBuffer.wrap(<span class="hljs-string">"lock"</span>.getBytes()));       lockFile.getChannel().force(<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">this</span>.flushConsumeQueueService.start();       <span class="hljs-keyword">this</span>.commitLog.start();       <span class="hljs-keyword">this</span>.storeStatsService.start();       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.scheduleMessageService != <span class="hljs-keyword">null</span> &amp;&amp; SLAVE != messageStoreConfig.getBrokerRole()) &#123;           <span class="hljs-keyword">this</span>.scheduleMessageService.start();       &#125;       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getMessageStoreConfig().isDuplicationEnable()) &#123;           <span class="hljs-keyword">this</span>.reputMessageService.setReputFromOffset(<span class="hljs-keyword">this</span>.commitLog.getConfirmOffset());       &#125; <span class="hljs-keyword">else</span> &#123;           <span class="hljs-keyword">this</span>.reputMessageService.setReputFromOffset(<span class="hljs-keyword">this</span>.commitLog.getMaxOffset());       &#125;       <span class="hljs-keyword">this</span>.reputMessageService.start();       <span class="hljs-keyword">this</span>.haService.start();       <span class="hljs-keyword">this</span>.createTempFile();       <span class="hljs-keyword">this</span>.addScheduleTask();       <span class="hljs-keyword">this</span>.shutdown = <span class="hljs-keyword">false</span>;   &#125;</code></pre><ol><li>flushConsumeQueueService作用是用来持久化一些producer发送到对应topic中的的不同队列的消息，核心代码如下：</li></ol><pre><code class="hljs java">ConcurrentMap&lt;String, ConcurrentMap&lt;Integer, ConsumeQueue&gt;&gt; tables = DefaultMessageStore.<span class="hljs-keyword">this</span>.consumeQueueTable;         <span class="hljs-comment">// 针对不同topic的每个消费队列进行消息读取并刷新到commitLog</span>         <span class="hljs-keyword">for</span> (ConcurrentMap&lt;Integer, ConsumeQueue&gt; maps : tables.values()) &#123;             <span class="hljs-keyword">for</span> (ConsumeQueue cq : maps.values()) &#123;                 <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;                 <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; retryTimes &amp;&amp; !result; i++) &#123;                     result = cq.flush(flushConsumeQueueLeastPages);                 &#125;             &#125;         &#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">flush</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> flushLeastPages)</span> </span>&#123;     <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">true</span>;     MappedFile mappedFile = <span class="hljs-keyword">this</span>.findMappedFileByOffset(<span class="hljs-keyword">this</span>.flushedWhere, <span class="hljs-keyword">this</span>.flushedWhere == <span class="hljs-number">0</span>);     <span class="hljs-keyword">if</span> (mappedFile != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">long</span> tmpTimeStamp = mappedFile.getStoreTimestamp();         <span class="hljs-keyword">int</span> offset = mappedFile.flush(flushLeastPages);         <span class="hljs-keyword">long</span> where = mappedFile.getFileFromOffset() + offset;         result = where == <span class="hljs-keyword">this</span>.flushedWhere;         <span class="hljs-keyword">this</span>.flushedWhere = where;         <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == flushLeastPages) &#123;             <span class="hljs-keyword">this</span>.storeTimestamp = tmpTimeStamp;         &#125;     &#125;     <span class="hljs-keyword">return</span> result; &#125;</code></pre><p>其中flushConsumeQueueLeastPages用来确定一次最终刷多少页的数据到磁盘，findMappedFileByOffset方法可以确定当前应该刷新哪个文件中，因为在commitLog中维护一个名为mapedFileQueue的文件映射队列，这个队列记录了所有的记录消息的映射文件。每个文件大小默认为1G。这样通过上次刷新的偏移量就能确定mapedFile。值得注意的时，在往文件中写的时候，会去检验文件是否可以写入(是否写满)，以及当前已写入到内存中的数据是否可以刷入指定页数的数据到磁盘，如果flushLeastPages 等于0的话就一次性将所有可以的落盘的数据一次性刷入磁盘(OS_PAGE_SIZE为操作系统默认的页大小)。</p><pre><code class="hljs java"> <span class="hljs-keyword">if</span> (flushLeastPages &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &gt;= flushLeastPages;        &#125;<span class="hljs-keyword">return</span> write &gt; flush;<span class="hljs-comment">// 最终刷盘的代码</span>   <span class="hljs-keyword">try</span> &#123;                       <span class="hljs-keyword">if</span> (writeBuffer != <span class="hljs-keyword">null</span> || <span class="hljs-keyword">this</span>.fileChannel.position() != <span class="hljs-number">0</span>) &#123;           <span class="hljs-keyword">this</span>.fileChannel.force(<span class="hljs-keyword">false</span>);       &#125; <span class="hljs-keyword">else</span> &#123;           <span class="hljs-keyword">this</span>.mappedByteBuffer.force();       &#125;   &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;       log.error(<span class="hljs-string">"Error occurred when force data to disk."</span>, e);   &#125;</code></pre><p>FileChannel.force()方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点，需要调用force()方法。参数标明是否将元数据一同刷入。</p><p><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/mw690/006HiYd9ly1g0oihjp0mrj313e0nw0um.jpg" srcset="/img/loading.gif" alt=""></p><ol start="2"><li>commitLog刷盘</li></ol><p>主要有两种刷盘方式进行选择：</p><ol><li>同步刷盘</li><li>异步刷盘(默认方式)</li></ol><p>刷盘方式在初始化commitLog指定</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CommitLog</span><span class="hljs-params">(<span class="hljs-keyword">final</span> DefaultMessageStore defaultMessageStore)</span> </span>&#123;    <span class="hljs-keyword">this</span>.mappedFileQueue = <span class="hljs-keyword">new</span> MappedFileQueue(defaultMessageStore.getMessageStoreConfig().getStorePathCommitLog(),        defaultMessageStore.getMessageStoreConfig().getMapedFileSizeCommitLog(), defaultMessageStore.getAllocateMappedFileService());    <span class="hljs-keyword">this</span>.defaultMessageStore = defaultMessageStore;    <span class="hljs-keyword">if</span> (FlushDiskType.SYNC_FLUSH == defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;        <span class="hljs-keyword">this</span>.flushCommitLogService = <span class="hljs-keyword">new</span> GroupCommitService();    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">this</span>.flushCommitLogService = <span class="hljs-keyword">new</span> FlushRealTimeService();    &#125;    <span class="hljs-keyword">this</span>.commitLogService = <span class="hljs-keyword">new</span> CommitRealTimeService();    <span class="hljs-keyword">this</span>.appendMessageCallback = <span class="hljs-keyword">new</span> DefaultAppendMessageCallback(defaultMessageStore.getMessageStoreConfig().getMaxMessageSize());    batchEncoderThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;MessageExtBatchEncoder&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> MessageExtBatchEncoder <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MessageExtBatchEncoder(defaultMessageStore.getMessageStoreConfig().getMaxMessageSize());        &#125;    &#125;;    <span class="hljs-keyword">this</span>.putMessageLock = defaultMessageStore.getMessageStoreConfig().isUseReentrantLockWhenPutMessage() ? <span class="hljs-keyword">new</span> PutMessageReentrantLock() : <span class="hljs-keyword">new</span> PutMessageSpinLock();&#125;</code></pre><p>(1) 同步刷盘：GroupCommitService</p><p>同步刷盘策略在设计上比较巧妙，采用一种交换锁的方式来减少线程的竞争，具体方式为两个队列，初始状态下，写队列用来存储请求，同时不断在读队列中获取获取刷盘请求，当请求处理完成后迅速交换引用。写队列指向读队列，读队列指向写队列，而请求的来源来自另一个不断从处理发送的消息的定时任务中来</p><p>​    关于队列中的数据来源，比较典型的就是延时消息，在broker启动时同步会启动一个投递延时消息的定时任务，</p><pre><code class="hljs java"><span class="hljs-comment">// 有需要发送的延时消息</span><span class="hljs-keyword">if</span> (msgExt != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">try</span> &#123;        MessageExtBrokerInner msgInner = <span class="hljs-keyword">this</span>.messageTimeup(msgExt);        PutMessageResult putMessageResult =            ScheduleMessageService.<span class="hljs-keyword">this</span>.defaultMessageStore            .putMessage(msgInner);<span class="hljs-comment">// 这里开始发送消息</span>        <span class="hljs-keyword">if</span> (putMessageResult != <span class="hljs-keyword">null</span>            &amp;&amp; putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) &#123;            <span class="hljs-keyword">continue</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// <span class="hljs-doctag">XXX:</span> warn and notify me</span>            log.error(                <span class="hljs-string">"ScheduleMessageService, a message time up, but reput it failed, topic: &#123;&#125; msgId &#123;&#125;"</span>,                msgExt.getTopic(), msgExt.getMsgId());            ScheduleMessageService.<span class="hljs-keyword">this</span>.timer.schedule(                <span class="hljs-keyword">new</span> DeliverDelayedMessageTimerTask(<span class="hljs-keyword">this</span>.delayLevel,                                                   nextOffset), DELAY_FOR_A_PERIOD);            ScheduleMessageService.<span class="hljs-keyword">this</span>.updateOffset(<span class="hljs-keyword">this</span>.delayLevel,                                                     nextOffset);            <span class="hljs-keyword">return</span>;        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        log.error(            <span class="hljs-string">"ScheduleMessageService, messageTimeup execute error, drop it. msgExt="</span>            + msgExt + <span class="hljs-string">", nextOffset="</span> + nextOffset + <span class="hljs-string">",offsetPy="</span>            + offsetPy + <span class="hljs-string">",sizePy="</span> + sizePy, e);    &#125;&#125;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> PutMessageResult <span class="hljs-title">putMessage</span><span class="hljs-params">(<span class="hljs-keyword">final</span> MessageExtBrokerInner msg)</span> </span>&#123;        <span class="hljs-comment">// Set the storage time</span>        msg.setStoreTimestamp(System.currentTimeMillis());        <span class="hljs-comment">// Set the message body BODY CRC (consider the most appropriate setting</span>        <span class="hljs-comment">// on the client)</span>        msg.setBodyCRC(UtilAll.crc32(msg.getBody()));        <span class="hljs-comment">// Back to Results</span>        AppendMessageResult result = <span class="hljs-keyword">null</span>;        StoreStatsService storeStatsService = <span class="hljs-keyword">this</span>.defaultMessageStore.getStoreStatsService();        String topic = msg.getTopic();        <span class="hljs-keyword">int</span> queueId = msg.getQueueId();        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());        <span class="hljs-keyword">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE            || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;            <span class="hljs-comment">// Delay Delivery</span>            <span class="hljs-keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="hljs-keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;                    msg.setDelayTimeLevel(<span class="hljs-keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());                &#125;                topic = ScheduleMessageService.SCHEDULE_TOPIC;                queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());                <span class="hljs-comment">// Backup real topic, queueId</span>                MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());                MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));                msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));                msg.setTopic(topic);                msg.setQueueId(queueId);            &#125;        &#125;        <span class="hljs-keyword">long</span> eclipseTimeInLock = <span class="hljs-number">0</span>;        MappedFile unlockMappedFile = <span class="hljs-keyword">null</span>;        MappedFile mappedFile = <span class="hljs-keyword">this</span>.mappedFileQueue.getLastMappedFile();        putMessageLock.lock(); <span class="hljs-comment">//spin or ReentrantLock ,depending on store config</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">long</span> beginLockTimestamp = <span class="hljs-keyword">this</span>.defaultMessageStore.getSystemClock().now();            <span class="hljs-keyword">this</span>.beginTimeInLock = beginLockTimestamp;            <span class="hljs-comment">// Here settings are stored timestamp, in order to ensure an orderly</span>            <span class="hljs-comment">// global</span>            msg.setStoreTimestamp(beginLockTimestamp);            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == mappedFile || mappedFile.isFull()) &#123;                mappedFile = <span class="hljs-keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="hljs-number">0</span>); <span class="hljs-comment">// Mark: NewFile may be cause noise</span>            &#125;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == mappedFile) &#123;                log.error(<span class="hljs-string">"create mapped file1 error, topic: "</span> + msg.getTopic() + <span class="hljs-string">" clientAddr: "</span> + msg.getBornHostString());                beginTimeInLock = <span class="hljs-number">0</span>;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, <span class="hljs-keyword">null</span>);            &#125;<span class="hljs-comment">// 这里会对消息进行一定格式的组装</span>            result = mappedFile.appendMessage(msg, <span class="hljs-keyword">this</span>.appendMessageCallback);                      eclipseTimeInLock = <span class="hljs-keyword">this</span>.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;            beginTimeInLock = <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">finally</span> &#123;            putMessageLock.unlock();        &#125;        <span class="hljs-keyword">if</span> (eclipseTimeInLock &gt; <span class="hljs-number">500</span>) &#123;            log.warn(<span class="hljs-string">"[NOTIFYME]putMessage in lock cost time(ms)=&#123;&#125;, bodyLength=&#123;&#125; AppendMessageResult=&#123;&#125;"</span>, eclipseTimeInLock, msg.getBody().length, result);        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != unlockMappedFile &amp;&amp; <span class="hljs-keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;            <span class="hljs-keyword">this</span>.defaultMessageStore.unlockMappedFile(unlockMappedFile);        &#125;        PutMessageResult putMessageResult = <span class="hljs-keyword">new</span> PutMessageResult(PutMessageStatus.PUT_OK, result);<span class="hljs-comment">// 这里就是将数据放入队列中以便后续刷盘</span>        handleDiskFlush(result, putMessageResult, msg);        handleHA(result, putMessageResult, msg);        <span class="hljs-keyword">return</span> putMessageResult;    &#125;</code></pre><p>在appendMessage这个方法之中，会对要发送的消息进行数据格式的封装(主要格式见下表)以及消息格式，长度的的一些校验，并且将延时消息的topic替换成真实的topic(每一个延时消息为了不会被消费者提前消费，会用一个特殊的名叫<strong>SCHEDULE_TOPIC_XXXX</strong>的topic替换，该topic是不会注册到namesrv的)，最终将消息存储在commitLog之中以便后续消费者可以进行消费</p><p>(2) 异步刷盘：FlushRealTimeService</p><p>同步刷盘要求刷盘完成才处理下面的请求，吞吐量不是很好，异步刷盘则是则是在后台默默落盘，每隔一段时间就从内存缓冲区同步一些数据(默认是4页的数据)</p><p><strong>消息格式</strong></p><table><thead><tr><th>第几位</th><th>字段</th><th>说明</th><th>数据类型</th><th>字节数</th></tr></thead><tbody><tr><td>1</td><td>MsgLen</td><td>消息总长度</td><td>Int</td><td>4</td></tr><tr><td>2</td><td>MagicCode</td><td>MESSAGE_MAGIC_CODE</td><td>Int</td><td>4</td></tr><tr><td>3</td><td>BodyCRC</td><td>消息内容CRC</td><td>Int</td><td>4</td></tr><tr><td>4</td><td>QueueId</td><td>消息队列编号</td><td>Int</td><td>4</td></tr><tr><td>5</td><td>Flag</td><td>flag</td><td>Int</td><td>4</td></tr><tr><td>6</td><td>QueueOffset</td><td>消息队列位置</td><td>Long</td><td>8</td></tr><tr><td>7</td><td>PhysicalOffset</td><td>物理位置。在 <code>CommitLog</code> 的顺序存储位置。</td><td>Long</td><td>8</td></tr><tr><td>8</td><td>SysFlag</td><td>MessageSysFlag</td><td>Int</td><td>4</td></tr><tr><td>9</td><td>BornTimestamp</td><td>生成消息时间戳</td><td>Long</td><td>8</td></tr><tr><td>10</td><td>BornHost</td><td>生效消息的地址+端口</td><td>Long</td><td>8</td></tr><tr><td>11</td><td>StoreTimestamp</td><td>存储消息时间戳</td><td>Long</td><td>8</td></tr><tr><td>12</td><td>StoreHost</td><td>存储消息的地址+端口</td><td>Long</td><td>8</td></tr><tr><td>13</td><td>ReconsumeTimes</td><td>重新消费消息次数</td><td>Int</td><td>4</td></tr><tr><td>14</td><td>PreparedTransationOffset</td><td></td><td>Long</td><td>8</td></tr><tr><td>15</td><td>BodyLength + Body</td><td>内容长度 + 内容</td><td>Int + Bytes</td><td>4 + bodyLength</td></tr><tr><td>16</td><td>TopicLength + Topic</td><td>Topic长度 + Topic</td><td>Byte + Bytes</td><td>1 + topicLength</td></tr><tr><td>17</td><td>PropertiesLength + Properties</td><td>拓展字段长度 + 拓展字段</td><td>Short + Bytes</td><td>2 + PropertiesLength</td></tr></tbody></table><p>除此之外，不论采取哪种刷盘策略，CommitRealTimeService这个服务是一定会初始化的，只不过需要在transientStorePoolEnable字段设为true才行并且刷盘策略为异步情况下且当且broker为master情况下才行，这样一来，CommitRealTimeService服务往往也是和FlushRealTimeService服务一起出现的</p><p>与FlushRealTimeService大部分的流程差不多，都是每次读取刷盘页数，然后找到对应的mappedFile进行写入，仔细观察却别在于一个调用flush方法，一个则是commit方法，如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">flush</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> flushLeastPages)</span> </span>&#123;       <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">true</span>;       MappedFile mappedFile = <span class="hljs-keyword">this</span>.findMappedFileByOffset(<span class="hljs-keyword">this</span>.flushedWhere, <span class="hljs-keyword">this</span>.flushedWhere == <span class="hljs-number">0</span>);       <span class="hljs-keyword">if</span> (mappedFile != <span class="hljs-keyword">null</span>) &#123;           <span class="hljs-keyword">long</span> tmpTimeStamp = mappedFile.getStoreTimestamp();           <span class="hljs-keyword">int</span> offset = mappedFile.flush(flushLeastPages);<span class="hljs-comment">//区别</span>           <span class="hljs-keyword">long</span> where = mappedFile.getFileFromOffset() + offset;           result = where == <span class="hljs-keyword">this</span>.flushedWhere;           <span class="hljs-keyword">this</span>.flushedWhere = where;           <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == flushLeastPages) &#123;               <span class="hljs-keyword">this</span>.storeTimestamp = tmpTimeStamp;           &#125;       &#125;       <span class="hljs-keyword">return</span> result;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">commit</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> commitLeastPages)</span> </span>&#123;       <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">true</span>;       <span class="hljs-comment">// 获取上次所写入的commitLog 文件</span>       MappedFile mappedFile = <span class="hljs-keyword">this</span>.findMappedFileByOffset(<span class="hljs-keyword">this</span>.committedWhere, <span class="hljs-keyword">this</span>.committedWhere == <span class="hljs-number">0</span>);       <span class="hljs-keyword">if</span> (mappedFile != <span class="hljs-keyword">null</span>) &#123;           <span class="hljs-comment">// 找到文件后再写入这次的</span>           <span class="hljs-keyword">int</span> offset = mappedFile.commit(commitLeastPages);<span class="hljs-comment">//区别</span>           <span class="hljs-keyword">long</span> where = mappedFile.getFileFromOffset() + offset;           result = where == <span class="hljs-keyword">this</span>.committedWhere;           <span class="hljs-keyword">this</span>.committedWhere = where;       &#125;       <span class="hljs-keyword">return</span> result;   &#125;</code></pre><p>而flush和commit方法细节如下(以下均省略细节)：</p><pre><code class="hljs java"><span class="hljs-comment">//flush</span><span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">if</span> (writeBuffer != <span class="hljs-keyword">null</span> || <span class="hljs-keyword">this</span>.fileChannel.position() != <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">this</span>.fileChannel.force(<span class="hljs-keyword">false</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">this</span>.mappedByteBuffer.force();    &#125;&#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;    log.error(<span class="hljs-string">"Error occurred when force data to disk."</span>, e);&#125;<span class="hljs-comment">//commit</span><span class="hljs-keyword">try</span> &#123;    ByteBuffer byteBuffer = writeBuffer.slice();    byteBuffer.position(lastCommittedPosition);    byteBuffer.limit(writePos);    <span class="hljs-keyword">this</span>.fileChannel.position(lastCommittedPosition);    <span class="hljs-keyword">this</span>.fileChannel.write(byteBuffer);    <span class="hljs-comment">// 重置上次提交的位置</span>    <span class="hljs-keyword">this</span>.committedPosition.set(writePos);&#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;    log.error(<span class="hljs-string">"Error occurred when commit data to FileChannel."</span>, e);&#125;</code></pre><p>commit方法会在每次执行时构造出一个写缓冲buffer，然后通过fileChannel进行写入，中间隔了一个内存字节缓存，而flush就简单粗暴一些，直接请求操作系统将数据一次性刷入磁盘(force是因为操作系统一般为了提高写入效率会将数据放在缓冲中批量写入，所以force可以强制要求其此时立即将数据写入)</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息中间件</tag>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ学习(三) producer</title>
    <link href="/2018/08/25/RocketMQ%E5%AD%A6%E4%B9%A0-%E4%B8%89-producer/"/>
    <url>/2018/08/25/RocketMQ%E5%AD%A6%E4%B9%A0-%E4%B8%89-producer/</url>
    
    <content type="html"><![CDATA[<p>RockterMq本质上作为一个高性能的消息中间件，通过消息来联动各个系统的状态，作为消息发起方的producer自然有必要了解一下其中的原理。讲解以官方demo为基础。</p><hr><h3 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h3><p>在实例化一个producer之后，首先需要进行一系列数据初始化，这些初始化操作为后面的数据发送奠定基础。</p><p>以默认的DefaultMQProducer类为例：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> startFactory)</span> <span class="hljs-keyword">throws</span> MQClientException </span>&#123;       <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.serviceState) &#123;           <span class="hljs-keyword">case</span> CREATE_JUST:               <span class="hljs-keyword">this</span>.serviceState = ServiceState.START_FAILED;               <span class="hljs-keyword">this</span>.checkConfig();               <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;                   <span class="hljs-keyword">this</span>.defaultMQProducer.changeInstanceNameToPID();               &#125;<span class="hljs-comment">// 1</span>               <span class="hljs-keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="hljs-keyword">this</span>.defaultMQProducer, rpcHook);<span class="hljs-comment">// 2</span>               <span class="hljs-keyword">boolean</span> registerOK = mQClientFactory.registerProducer(<span class="hljs-keyword">this</span>.defaultMQProducer.getProducerGroup(), <span class="hljs-keyword">this</span>);               <span class="hljs-keyword">if</span> (!registerOK) &#123;                   <span class="hljs-keyword">this</span>.serviceState = ServiceState.CREATE_JUST;                   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MQClientException(<span class="hljs-string">"The producer group["</span> + <span class="hljs-keyword">this</span>.defaultMQProducer.getProducerGroup()                       + <span class="hljs-string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),                       <span class="hljs-keyword">null</span>);               &#125;               <span class="hljs-keyword">this</span>.topicPublishInfoTable.put(<span class="hljs-keyword">this</span>.defaultMQProducer.getCreateTopicKey(), <span class="hljs-keyword">new</span> TopicPublishInfo());               <span class="hljs-keyword">if</span> (startFactory) &#123;                   <span class="hljs-comment">// 3</span>                   mQClientFactory.start();               &#125;               log.info(<span class="hljs-string">"the producer [&#123;&#125;] start OK. sendMessageWithVIPChannel=&#123;&#125;"</span>, <span class="hljs-keyword">this</span>.defaultMQProducer.getProducerGroup(),                   <span class="hljs-keyword">this</span>.defaultMQProducer.isSendMessageWithVIPChannel());               <span class="hljs-keyword">this</span>.serviceState = ServiceState.RUNNING;               <span class="hljs-keyword">break</span>;           <span class="hljs-keyword">case</span> RUNNING:           <span class="hljs-keyword">case</span> START_FAILED:           <span class="hljs-keyword">case</span> SHUTDOWN_ALREADY:               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MQClientException(<span class="hljs-string">"The producer service state not OK, maybe started once, "</span>                   + <span class="hljs-keyword">this</span>.serviceState                   + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),                   <span class="hljs-keyword">null</span>);           <span class="hljs-keyword">default</span>:               <span class="hljs-keyword">break</span>;       &#125;    <span class="hljs-comment">// 4</span>       <span class="hljs-keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();   &#125;</code></pre><ol><li>从第一点可以看出RocketMq(以下简称rmq)对于不同的客户端是通过不同clientIp和instanceName，这反映了rmq在分辨客户端时可以将其看成一台机器或是一个标准进程。</li><li>将上一步生成的客户端与生产者组名关联起来并缓存起来</li><li>启动mq客户端实例，这一步也是完成数据初始化的关键步骤</li><li>向broker发送心跳包</li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MQClientException </span>&#123;       <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;           <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.serviceState) &#123;               <span class="hljs-keyword">case</span> CREATE_JUST:                   <span class="hljs-keyword">this</span>.serviceState = ServiceState.START_FAILED;                   <span class="hljs-comment">// If not specified,looking address from name server</span>                   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == <span class="hljs-keyword">this</span>.clientConfig.getNamesrvAddr()) &#123;                       <span class="hljs-keyword">this</span>.mQClientAPIImpl.fetchNameServerAddr();                   &#125;                   <span class="hljs-comment">// 初始化netty连接，方便后续消息发送</span>                   <span class="hljs-keyword">this</span>.mQClientAPIImpl.start();                                     <span class="hljs-keyword">this</span>.startScheduledTask();                   <span class="hljs-comment">// 开始持续拉取消息消费</span>                   <span class="hljs-keyword">this</span>.pullMessageService.start();                   <span class="hljs-comment">// 主要是调整具体消费的队列，之后介绍消费者会详述</span>                   <span class="hljs-keyword">this</span>.rebalanceService.start();                   <span class="hljs-comment">// Start push service</span>                   <span class="hljs-keyword">this</span>.defaultMQProducer.getDefaultMQProducerImpl().start(<span class="hljs-keyword">false</span>);                   log.info(<span class="hljs-string">"the client factory [&#123;&#125;] start OK"</span>, <span class="hljs-keyword">this</span>.clientId);                   <span class="hljs-keyword">this</span>.serviceState = ServiceState.RUNNING;                   <span class="hljs-keyword">break</span>;               <span class="hljs-keyword">case</span> RUNNING:                   <span class="hljs-keyword">break</span>;               <span class="hljs-keyword">case</span> SHUTDOWN_ALREADY:                   <span class="hljs-keyword">break</span>;               <span class="hljs-keyword">case</span> START_FAILED:                   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MQClientException(<span class="hljs-string">"The Factory object["</span> + <span class="hljs-keyword">this</span>.getClientId() + <span class="hljs-string">"] has been created before, and failed."</span>, <span class="hljs-keyword">null</span>);               <span class="hljs-keyword">default</span>:                   <span class="hljs-keyword">break</span>;           &#125;       &#125;   &#125;</code></pre><pre><code>其中startScheduledTask方法用于启动各种定时任务(所有任务都是泡在一个单例线程池中以节省资源)</code></pre><ol><li>包括定时拉取namesrv地址</li><li>从namesrv获取最新的路由信息，包括获取本地消费组下订阅不同topic的消费组信息，不同生产者组中生产者信息，以及最为重要的是还会检测上述topic(topic就是上述消费者和生产者关联的topic信息)下的路由信息是否发生变更，变更的话需要重新获取相应的路由信息(什么是路由信息在发送消息环节会详述)</li><li>向broker定时发送心跳包来更新当前的客户端的生存状态</li><li>持久化本地消费记录信息</li></ol><hr><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><pre><code>对于rmq消息而言，主要包含三个部分(两个必填，一个可选)：topic，tag以及key。对于三者的关系，一句话概括就是一本书，它表达出具体消息关注某一方面(比如金融书，计算机类书)，tag则是书的章节，侧重描述某一细节，key的作用主要用于标识消息的唯一性，不过考虑到消息本身带有的id属性，这一个也可以不填。</code></pre><p>对于发送消息，主要有三种方式：同步，异步和单向传输。producer在发送消息时会选择一个namesrv，从而获取到broker的相关信息。由于每个namesrv是独立存在的，因而我们可以随机选取一台建立连接并通信，建立连接失败的话就接着选取下一台就行了。具体选择的代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> List&lt;String&gt; addrList = <span class="hljs-keyword">this</span>.namesrvAddrList.get();        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lockNamesrvChannel.tryLock(LOCK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) &#123;            <span class="hljs-keyword">try</span> &#123;                addr = <span class="hljs-keyword">this</span>.namesrvAddrChoosed.get();                <span class="hljs-keyword">if</span> (addr != <span class="hljs-keyword">null</span>) &#123;                    ChannelWrapper cw = <span class="hljs-keyword">this</span>.channelTables.get(addr);                    <span class="hljs-keyword">if</span> (cw != <span class="hljs-keyword">null</span> &amp;&amp; cw.isOK()) &#123;                        <span class="hljs-keyword">return</span> cw.getChannel();                    &#125;                &#125;                <span class="hljs-keyword">if</span> (addrList != <span class="hljs-keyword">null</span> &amp;&amp; !addrList.isEmpty()) &#123;                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; addrList.size(); i++) &#123;                        <span class="hljs-keyword">int</span> index = <span class="hljs-keyword">this</span>.namesrvIndex.incrementAndGet();                        index = Math.abs(index);                        index = index % addrList.size();                        String newAddr = addrList.get(index);                        <span class="hljs-keyword">this</span>.namesrvAddrChoosed.set(newAddr);                        log.info(<span class="hljs-string">"new name server is chosen. OLD: &#123;&#125; , NEW: &#123;&#125;. namesrvIndex = &#123;&#125;"</span>, addr, newAddr, namesrvIndex);                        Channel channelNew = <span class="hljs-keyword">this</span>.createChannel(newAddr);                        <span class="hljs-keyword">if</span> (channelNew != <span class="hljs-keyword">null</span>) &#123;                            <span class="hljs-keyword">return</span> channelNew;                        &#125;                    &#125;                &#125;            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                log.error(<span class="hljs-string">"getAndCreateNameserverChannel: create name server channel exception"</span>, e);            &#125; <span class="hljs-keyword">finally</span> &#123;                <span class="hljs-keyword">this</span>.lockNamesrvChannel.unlock();            &#125;</code></pre><blockquote><p>namesrvIndex的初始化是由如下代码执行的</p><pre><code class="hljs java">&gt;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">initValueIndex</span><span class="hljs-params">()</span> </span>&#123;   Random r = <span class="hljs-keyword">new</span> Random();   <span class="hljs-keyword">return</span> Math.abs(r.nextInt() % <span class="hljs-number">999</span>) % <span class="hljs-number">999</span>;&gt;&#125;</code></pre></blockquote><p>根据发送的topic去寻找对应的broker信息，找不到会直接请求namesrv来获取路由信息(包含broker信息以及topic下的队列信息)。通过namesrv知道topic下的队列信息，再通过队列信息找到对应的broker(队列信息中会包含所属的broker)，从而间接建立topic和broker的映射关系，以便后续消息存储消费走对应的broker。这样一来，消息发送的压力就平摊到不同的broker上面，主要关系如下图：</p><p><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/006HiYd9ly1g09qr5rwnaj313y0jotdc.jpg" srcset="/img/loading.gif" alt=""></p><p>通过将不同的message queue划分到不同的broker group中，所以对于客户端来说，分布在不同broker group的message queue成为一个服务集群，但客户端会把请求分摊到不同的queue。这样对消息的存储和转发均起到了负载均衡的作用。</p><h4 id="消息发送方式"><a href="#消息发送方式" class="headerlink" title="消息发送方式"></a>消息发送方式</h4><ol><li><p>同步方式(SYNC)：</p><blockquote><p>同步消息发送是三种发送方式中唯一会直接返回发送结果的。第一次会随机从topic下选择message queue进行消息投递，随后就是依次向不同的message queue投递消息。在发送失败后会重试(默认重试两次)。并最终将发送结果返回(发送结果的获取是利用countDownLatch的超时机制实现的)。</p></blockquote></li><li><p>异步发送(ASYNC)：</p><blockquote><p>异步发送流程上没有太多区别，主要就是发送结果会在返回响应后通过回调函数将通知包装在请求上下文</p></blockquote></li><li><p>单向(Oneway)发送：只负责发送消息，不等待服务器回应且没有回调函数触发，即只发送请求不等待应答。此方式发送消息的过程耗时非常短。但是对发送可靠性不作保障，比较适合像日志收集，应用埋点等需求。</p></li></ol><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><pre><code>rmq也支持顺序消息，不过这种消息只限于将消息投递到某个topic下的一个message queue中，考虑到全局有序对性能影响较大具体可以参考[分布式开放消息系统(RocketMQ)的原理与实践](https://www.jianshu.com/p/453c6e7ff81c), 里面有一些，而在沈询之前讨论mq设计的视频中也说明过(详见[阿里分布式开放消息服务(ONS)原理与实践](http://i.youku.com/u/UMTcwMTg3NDc1Mg==?from=113-2-1-2))。此外rmq也支持发送批量消息，以官网为例：</code></pre><pre><code class="hljs java">String topic = <span class="hljs-string">"BatchTest"</span>;List&lt;Message&gt; messages = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();messages.add(<span class="hljs-keyword">new</span> Message(topic, <span class="hljs-string">"TagA"</span>, <span class="hljs-string">"OrderID001"</span>, <span class="hljs-string">"Hello world 0"</span>.getBytes()));messages.add(<span class="hljs-keyword">new</span> Message(topic, <span class="hljs-string">"TagA"</span>, <span class="hljs-string">"OrderID002"</span>, <span class="hljs-string">"Hello world 1"</span>.getBytes()));messages.add(<span class="hljs-keyword">new</span> Message(topic, <span class="hljs-string">"TagA"</span>, <span class="hljs-string">"OrderID003"</span>, <span class="hljs-string">"Hello world 2"</span>.getBytes()));<span class="hljs-keyword">try</span> &#123;    producer.send(messages);&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    e.printStackTrace();    <span class="hljs-comment">//handle the error</span>&#125;</code></pre><pre><code>rmq在一定程度上是支持定时消息的，不过延时时间不是由用户来决定的，因为这样一来就需要在broker层面对消息进行排序，就又回到了上述的弊端。因为rmq支持的延时级别，级别越高，延时越长：</code></pre><table><thead><tr><th align="center">延迟级别</th><th align="center">延时时长</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1s</td></tr><tr><td align="center">2</td><td align="center">5s</td></tr><tr><td align="center">3</td><td align="center">10s</td></tr><tr><td align="center">4</td><td align="center">30s</td></tr><tr><td align="center">5</td><td align="center">1m</td></tr><tr><td align="center">6</td><td align="center">2m</td></tr><tr><td align="center">7</td><td align="center">3m</td></tr><tr><td align="center">8</td><td align="center">4m</td></tr><tr><td align="center">9</td><td align="center">5m</td></tr><tr><td align="center">10</td><td align="center">6m</td></tr><tr><td align="center">11</td><td align="center">7m</td></tr><tr><td align="center">12</td><td align="center">8m</td></tr><tr><td align="center">13</td><td align="center">9m</td></tr><tr><td align="center">14</td><td align="center">10m</td></tr><tr><td align="center">15</td><td align="center">20m</td></tr><tr><td align="center">16</td><td align="center">30m</td></tr><tr><td align="center">17</td><td align="center">1h</td></tr><tr><td align="center">18</td><td align="center">2h</td></tr></tbody></table><p>在发送时，设置：</p><pre><code class="hljs java">Message message = <span class="hljs-keyword">new</span> Message(<span class="hljs-string">"TestTopic"</span>, (<span class="hljs-string">"Hello scheduled message"</span>).getBytes());msg.setDelayTimeLevel(level);</code></pre><p>具体代码在org.apache.rocketmq.store.schedule.ScheduleMessageService的parseDelayLevel方法中，可见producer是不会对延时消息做任何处理，就像普通消息发送出去，在broker那再作处理。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息中间件</tag>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ学习(一) namesrv</title>
    <link href="/2018/06/24/RocketMQ%E5%AD%A6%E4%B9%A0-namesrv/"/>
    <url>/2018/06/24/RocketMQ%E5%AD%A6%E4%B9%A0-namesrv/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><pre><code>因为最近项目的原因用上了消息队列，且技术选型用的是RocketMQ，因而抽空花时间研究了一下其中的几个核心组件的原理(包括namesrv，broker，consumer，producer，当然RocketMQ如何处理消息堆积以及消息落盘的处理也是精华)。本文的分析是基于RocketMQ—4.3版本源码。</code></pre><blockquote><p>首先依据RocketMQ的官方文档明确以下几个概念，方便后续描述：</p><ol><li><p>Producer：消息生产者，负责产生消息，一般由业务系统负责产生消息。</p></li><li><p>Consumer：消息消费者，负责消费消息，一般是后台系统负责异步消费。</p><p>2.1 Push Consumer：Consumer 的一种，应用通常向 Consumer 对象注册一个 Listener 接口，一旦收到消息，Consumer 对象立 刻回调 Listener 接口方法。</p><p>2.2 Pull Consumer：Consumer 的一种，应用通常主动调用 Consumer 的拉消息方法从 Broker 拉消息，主动权由应用控制。</p></li><li><p>Producer Group：一类 Producer 的集合名称，这类 Producer 通常发送一类消息，且发送逻辑一致。</p></li><li><p>Consumer Group：一类 Consumer 的集合名称，这类 Consumer 通常消费一类消息，且消费逻辑一致。</p></li><li><p>Broker：消息中转角色，负责存储消息，转发消息，一般也称为 Server。在 JMS 规范中称为 Provider。</p></li><li><p>广播消费：一条消息被多个 Consumer 消费，即使这些 Consumer 属于同一个 Consumer Group，消息也会被 Consumer Group 中的每个 Consumer 都消费一次，广播消费中的 Consumer Group 概念可以认为在消息划分方面无意 义。</p></li><li><p>集群消费：一个 Consumer Group 中的 Consumer 实例平均分摊消费消息。例如某个 Topic 有 9 条消息，其中一个 Consumer Group 有 3 个实例（可能是 3 个进程，或者 3 台机器），那么每个实例只消费其中的 3 条消息。</p></li></ol></blockquote><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>RocketMQ 的namesrv启动流程是在类NamesrvStartup中完成的。它的主要流程如下：</p><ol><li><p>完成命令行参数的解析和封装(方便后续随时读取)到NamesrvController对象之中，当然如果你有-c 参数会促使 mq 从指定配置文件中读取相应的信息</p></li><li><p>完成一系列初始化过程</p><p>2.1 初始化一些 kv 配置信息</p><p>2.2 实例化一个nettyserver对象</p><p>2.3 注册 Processer线程池用来处理后续根据 request code 来处理请求</p><p>2.4 启动一个单例线程池定时交替扫描不活跃的broker以及打印一些kv配置信息</p></li><li><p>启动 netty 服务</p></li></ol><h3 id="namesrv-初始化"><a href="#namesrv-初始化" class="headerlink" title="namesrv 初始化"></a>namesrv 初始化</h3><p>关于 namesrv 的初始化，主要有以下代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.kvConfigManager.load();        <span class="hljs-keyword">this</span>.remotingServer = <span class="hljs-keyword">new</span> NettyRemotingServer(<span class="hljs-keyword">this</span>.nettyServerConfig, <span class="hljs-keyword">this</span>.brokerHousekeepingService);        <span class="hljs-keyword">this</span>.remotingExecutor =            Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), <span class="hljs-keyword">new</span> ThreadFactoryImpl(<span class="hljs-string">"RemotingExecutorThread_"</span>));        <span class="hljs-keyword">this</span>.registerProcessor();        <span class="hljs-keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                NamesrvController.<span class="hljs-keyword">this</span>.routeInfoManager.scanNotActiveBroker();            &#125;        &#125;, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);        <span class="hljs-keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                NamesrvController.<span class="hljs-keyword">this</span>.kvConfigManager.printAllPeriodically();            &#125;        &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, TimeUnit.MINUTES);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerProcessor</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (namesrvConfig.isClusterTest()) &#123;            <span class="hljs-keyword">this</span>.remotingServer.registerDefaultProcessor(<span class="hljs-keyword">new</span> ClusterTestRequestProcessor(<span class="hljs-keyword">this</span>, namesrvConfig.getProductEnvName()),                <span class="hljs-keyword">this</span>.remotingExecutor);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">this</span>.remotingServer.registerDefaultProcessor(<span class="hljs-keyword">new</span> DefaultRequestProcessor(<span class="hljs-keyword">this</span>), <span class="hljs-keyword">this</span>.remotingExecutor);        &#125;    &#125;</code></pre><p> 在以上启动流程的初始化中，mq有一些初始化Processer线程池的操作，在registerProcessor方法中，会将 nettyserver 和对应的Processer线程池绑定起来，而Processer内部的processRequest方法则负责将根据将来 request code来区分不同的请求类型(比如 broker 的注册也是其中一种).</p><p> 除此之外，在初始化默认的Processer线程池时(主要是防止在processorTable对象中不存在request code —&gt; Processor)，还关联一个processorTable对象，如下：</p><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> HashMap&lt;Integer<span class="hljs-comment">/* request code */</span>, Pair&lt;NettyRequestProcessor, ExecutorService&gt;&gt; processorTable =    <span class="hljs-keyword">new</span> HashMap&lt;Integer, Pair&lt;NettyRequestProcessor, ExecutorService&gt;&gt;(<span class="hljs-number">64</span>);</code></pre><p>这个对象就是将request code与具体处理请求的线程池的绑定关系记录下来，将来nettyServer接收到请求后，封装成任务提交到该线程池.</p><h3 id="namesrv设计思想"><a href="#namesrv设计思想" class="headerlink" title="namesrv设计思想"></a>namesrv设计思想</h3><p> 总体来说，namesrv是一个无状态，可任意水平扩展的服务，对于每一个namesrv而言，它无需与集群中的其它namesrv进行数据同步，所有的 broker 都会对所有的namesrv注册自己的信息并同时维护他们之前的心跳。而每一个namesrv也会拥有所有定时获取所有broker的信息。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息中间件</tag>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 异常处理机制小结</title>
    <link href="/2018/02/04/Spring-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%B0%8F%E7%BB%93/"/>
    <url>/2018/02/04/Spring-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>前几天想把公司某个项目中的参数处理通过某一种统一的机制进行封装后并将返回结果统一处理，参照资料后发现可以通过</p><p>JSR之前定义的一些参数校验标准来对一些进行简单的设置</p><blockquote><p>javax.validation.constraints包下面有如下注解:</p><table><thead><tr><th>注解</th><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>@Null</td><td>任意类型</td><td>必须为空</td></tr><tr><td>@NotNull</td><td>任意类型</td><td>必须不为空</td></tr><tr><td>@AssertFalse</td><td>boolean,Boolean</td><td>注解布尔值为false</td></tr><tr><td>@AssertTrue</td><td>同@AssertFalse</td><td>注解布尔值为true</td></tr><tr><td>@Max(value=值)</td><td>BigDecimal，BigInteger, byte,short, int, long，等任何Number</td><td>设置最大值</td></tr><tr><td>@Min(value=值)</td><td>同@Min</td><td>设置最小值</td></tr><tr><td>@DecimalMax(value=值)</td><td>同@Min</td><td>设置最大值</td></tr><tr><td>@Digits(integer=整数位数,fraction=小数位数)</td><td>同@Min</td><td>设置整数位和小数位的精度</td></tr><tr><td>@Future</td><td>java.util.Date,java.util.Calendar;Joda Time类库的日期类型</td><td>比当前时间晚</td></tr><tr><td>@Past</td><td>同@Future</td><td>比当前时间早</td></tr><tr><td>@Size(min=最小值,max=最大值)</td><td>字符串、Collection、Map、数组等</td><td>长度</td></tr><tr><td>@Pattern(regexp=正则表达式)</td><td>String</td><td>匹配正则表达式</td></tr></tbody></table><p>除此之外，还有Hibernate Validation提供的注解：</p><table><thead><tr><th>注解</th><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>@Range(min=最小值, max=最大值)</td><td>同@Min</td><td>验证注解的元素值在最小值和最大值之间</td></tr><tr><td>@URL</td><td>String</td><td>校验URL格式</td></tr><tr><td>@Email</td><td>String</td><td>校验Email格式</td></tr><tr><td>@NotBlank</td><td>String</td><td>不为null,不为””</td></tr><tr><td>@NotEmpty</td><td>任意类型</td><td>不为null,字符串长度不为0,集合大小不为0</td></tr></tbody></table></blockquote><pre><code>通过在一个 pojo 对象的 field 中加上这些注解并在 Controller 层对应的 pojo 对象前加上@Valid 注解就可以使用，并将校验不通过的异常信息包装在一个 BindingResult对象，整个处理十分方便，具体用法网上有很多，就不赘述了。</code></pre><hr><pre><code>上述对于这种校验需要包装一个完整的 pojo 对象，有时候在入参不多的情况下有点多余，一般就是对指定的参数校验，我就想在参数校验不通过的情况下对异常信息统一处理，于是马上想到可以通过 ExceptionHandler + ControllerAdvice注解的方式对进行统一处理，对于ConstraintViolationException这个异常进行捕获就可以了，可惜理想丰满现实骨感。在 web 容器加载后请求对应的mapping始终没有在@ExceptionHandler修饰的方法中捕获异常，这个配置方法和Spring提供的教程相差无几，为什么会没有处理…</code></pre><h3 id="Spring-统一的异常处理接口HandlerExceptionResolver"><a href="#Spring-统一的异常处理接口HandlerExceptionResolver" class="headerlink" title="Spring 统一的异常处理接口HandlerExceptionResolver"></a>Spring 统一的异常处理接口HandlerExceptionResolver</h3><p> 在 Spring 的整个异常处理体系中，HandlerExceptionResolver接口是一个基础入口，其中的resolveException方法专门用于处理请求过程中发生的Exception，参数如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span>;</code></pre><p>在对源码进行调试之后，发现请求流程中如下：</p><ol><li><p>对于所有的 http 请求，通过DispatcherServlet这个类进行分发，这个类是一个核心请求类，处理包括但不限于</p><ul><li>将请求参数请求解析并将解析后的参数放入 RequestMapping 修饰的方法的入参中</li><li>调用定义好的拦截器对方法进行增强</li><li>根据HttpServletRequest对象类型 将请求正确分发到对应 HandlerAdapter中</li><li>将处理好的请求结果封装到一个 ModelAndView 对象中返回，如果是直接返回到一个结果页面还要进行视图的渲染</li><li>对请求过程中异常的处理</li></ul></li><li><p>在请求处理完成后，有如下代码(省略一些次要代码，下同)</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;HttpServletRequest processedRequest = request;HandlerExecutionChain mappedHandler = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">boolean</span> multipartRequestParsed = <span class="hljs-keyword">false</span>;WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);<span class="hljs-keyword">try</span> &#123;ModelAndView mv = <span class="hljs-keyword">null</span>;Exception dispatchException = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// Determine handler for the current request.</span>mappedHandler = getHandler(processedRequest);<span class="hljs-keyword">if</span> (mappedHandler == <span class="hljs-keyword">null</span> || mappedHandler.getHandler() == <span class="hljs-keyword">null</span>) &#123;noHandlerFound(processedRequest, response);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">// Determine handler adapter for the current request.</span>HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());<span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">// Actually invoke the handler.</span>mv = ha.handle(processedRequest, response, mappedHandler.getHandler());mappedHandler.applyPostHandle(processedRequest, response, mv);&#125;<span class="hljs-keyword">catch</span> (Exception ex) &#123;dispatchException = ex;&#125;<span class="hljs-keyword">catch</span> (Throwable err) &#123;<span class="hljs-comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span><span class="hljs-comment">// making them available for @ExceptionHandler methods and other scenarios.</span>dispatchException = <span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">"Handler dispatch failed"</span>, err);&#125;processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);&#125;<span class="hljs-keyword">catch</span> (Exception ex) &#123;triggerAfterCompletion(processedRequest, response, mappedHandler, ex);&#125;<span class="hljs-keyword">catch</span> (Throwable err) &#123;triggerAfterCompletion(processedRequest, response, mappedHandler,<span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">"Handler processing failed"</span>, err));&#125;&#125;<span class="hljs-comment">// 在请求完成后会有对异常的检查和处理，由processDispatchResult方法的processHandlerException处理</span><span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">processHandlerException</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;ModelAndView exMv = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">// 遍历之前应用启动时所有在IOC容器中注册的异常处理器(都基于HandlerExceptionResolver接口)</span><span class="hljs-keyword">for</span> (HandlerExceptionResolver handlerExceptionResolver : <span class="hljs-keyword">this</span>.handlerExceptionResolvers) &#123;exMv = handlerExceptionResolver.resolveException(request, response, handler, ex);<span class="hljs-keyword">if</span> (exMv != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">throw</span> ex;&#125;</code></pre></li></ol><p>看到这里，基本可以发现大致的问题，我的这个项目在启动时只有项目的异常配置ExceptionResolver，于是我又新建一个可以使用@ExceptionHandler注解的项目，观察它的ExceptionResolver类型，对比后发现：</p><p>失效配置</p><p><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/006HiYd9ly1g09qr5kyhij30xu076400.jpg" srcset="/img/loading.gif" alt=""></p><p>正常配置</p><p><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/006HiYd9ly1g09qr5l4p5j30vm080wg6.jpg" srcset="/img/loading.gif" alt=""></p><p>继续跟踪一下发现在<strong>ExceptionHandlerExceptionResolver</strong>这个异常处理器</p><pre><code class="hljs java"><span class="hljs-comment">// ExceptionHandlerExceptionResolver内部用两个Map来存储所有ExceptionHandlerMethodResolver类，</span><span class="hljs-comment">// 他并不直接实现HandlerExceptionResolver接口，而是靠外部其它类来包装</span><span class="hljs-comment">// 在ExceptionHandlerMethodResolver中会去发现所有由@ExceptionHandler修饰的方法</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, ExceptionHandlerMethodResolver&gt; exceptionHandlerCache =<span class="hljs-keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, ExceptionHandlerMethodResolver&gt;(<span class="hljs-number">64</span>); <span class="hljs-comment">// 处理具体 Controller中的ExceptionHandler</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;ControllerAdviceBean, ExceptionHandlerMethodResolver&gt; exceptionHandlerAdviceCache =<span class="hljs-keyword">new</span> LinkedHashMap&lt;ControllerAdviceBean, ExceptionHandlerMethodResolver&gt;(); <span class="hljs-comment">//处理ControllerAdvice中的ExceptionHandler</span></code></pre><h3 id="Spring-中异常处理方式"><a href="#Spring-中异常处理方式" class="headerlink" title="Spring 中异常处理方式"></a>Spring 中异常处理方式</h3><p>很显然，Spring 对于异常的处理有以下几种方式：</p><ol><li>某一具体Controller方法中抛出的异常，由Controller中有@ExceptionHandler修饰的方法处理(如果异常类型可以匹配上的话)</li><li>通过ControllerAdvice + ExceptionHandler注解相结合的方法全局处理各个Controller中的异常</li><li>自定义异常解析器并实现HandlerExceptionResolver接口</li></ol><p>而在我这个ExceptionHandler注解失效项目中，显然采用第三种方法处理异常，并且我采用了@EnableWebMvc注解作为全局的 web 配置，默认这个配置会读取WebMvcConfigurationSupport这个类中的配置；但不幸的是这个配置会被继承WebMvcConfigurerAdapter或实现WebMvcConfigurer接口的配置类所覆盖，我们项目中正好继承了WebMvcConfigurerAdapter类并且只添加了一种自定义的异常解析器作为全局处理</p><pre><code class="hljs java">&gt; <span class="hljs-comment">// Java Doc 中对WebMvcConfigurationSupport异常解析器的部分描述</span>&gt; Registers a &#123;<span class="hljs-meta">@link</span> HandlerExceptionResolverComposite&#125; with <span class="hljs-keyword">this</span> chain of&gt; exception resolvers:&gt;&gt; &#123;<span class="hljs-meta">@link</span> ExceptionHandlerExceptionResolver&#125; <span class="hljs-keyword">for</span> handling exceptions&gt; through @&#123;<span class="hljs-meta">@link</span> ExceptionHandler&#125; methods.&gt; &#123;<span class="hljs-meta">@link</span> ResponseStatusExceptionResolver&#125; <span class="hljs-keyword">for</span> exceptions annotated&gt; with @&#123;<span class="hljs-meta">@link</span> ResponseStatus&#125;.&gt; &#123;<span class="hljs-meta">@link</span> DefaultHandlerExceptionResolver&#125; <span class="hljs-keyword">for</span> resolving known Spring&gt; exception types&gt;</code></pre><pre><code>看到这里，有人会问，当初继承WebMvcConfigurerAdapter这个类自定义配置是为了满足业务需求，尤其是异常这块希望有一个全局处理机制，但后来发现需要对某一特定异常进行处理的时候却发现ExceptionHandler注解失效，难道不能两种兼得吗？答案当然是可以，仔细查阅 Spring WebMvcConfigurer源码中的 Java Doc 发现，自定义的异常解析器有两种添加方法： </code></pre><pre><code class="hljs java"><span class="hljs-comment">// 以覆盖WebMvcConfigurationSupport的默认解析器方法重新定义异常解析器</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureHandlerExceptionResolvers</span><span class="hljs-params">(List&lt;HandlerExceptionResolver&gt; exceptionResolvers)</span> </span>&#123;&#125;<span class="hljs-comment">// 以继承WebMvcConfigurationSupport的默认解析器方法扩展异常解析器</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">extendHandlerExceptionResolvers</span><span class="hljs-params">(List&lt;HandlerExceptionResolver&gt; exceptionResolvers)</span> </span>&#123;&#125;</code></pre><p>显然，第二种就能满足我们的需求了，效果如下：</p><p><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/006HiYd9ly1g09qr5rx3hj30ue0awmzb.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础同步框架 - AbstractQueuedSynchronizer</title>
    <link href="/2018/01/21/%E5%9F%BA%E7%A1%80%E5%90%8C%E6%AD%A5%E6%A1%86%E6%9E%B6-AbstractQueuedSynchronizer/"/>
    <url>/2018/01/21/%E5%9F%BA%E7%A1%80%E5%90%8C%E6%AD%A5%E6%A1%86%E6%9E%B6-AbstractQueuedSynchronizer/</url>
    
    <content type="html"><![CDATA[<p>​    AbstractQueuedSynchronizer作为JUC包下面基础同步框架，为很多并发集合的提供许多基础的同步方法，它大体上分为两种同步模式：独占模式(ReentrantLock)以及共享模式(CountDownLatch)，但AbstractQueuedSynchronizer本身并不提供两种模式的具体实现，它的很多方法都交由子类在不同场景下进行按需实现，它最重大的作用实在内部构建一种CLH队列，由内部类 Node作为基础元素，它将入队的线程及其所处的模式关联起来。CLH 中的每个结点都必须由其前驱结点来唤醒。</p><hr><p>​    在AQS内部，通过将线程抽象为一个个Node对象存储在CLH队列之中，通过一个int型对象来标识线程的的状态：</p><blockquote><ol><li>CANCELLED(1) : 表示当前线程已经取消等待(超出等待时间或者由于被中断)，此时线程节点会从队列中移除</li><li>SIGNAL(-1)：表示当前线程是阻塞状态(如果此时是head节点将被唤醒)，在此之前必须释放后继节点</li><li>CONDITION(-2)：放入等待队列中的线程</li><li>PROPAGATE(-3)：在共享模式下，表示当前线程传递当前状态给后续所有等待获取共享资源而进入等待的线程</li></ol></blockquote><h3 id="独占模式-以ReentrantLock为例"><a href="#独占模式-以ReentrantLock为例" class="headerlink" title="独占模式(以ReentrantLock为例)"></a>独占模式(以ReentrantLock为例)</h3><blockquote><p>在ReentrantLock内部主要是实现了非公平锁以及公平锁策略，而独占模式是应用在这两种锁之下的。</p></blockquote><p>以ReentrantLock的 lock 方法作为入口:</p><p>任何尝试获得锁的线程都会先自检锁的持有状态，这个地方利用模板方法模式在tryAcquire中进行，这将由AQS子类来实现，不过都是需要设置exclusiveOwnerThread变量为当前线程引用，在ReentrantLock中为了实现可重入的特性，将AQS中的state定义为持有锁的次数</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;  <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;      acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="hljs-comment">// 尝试获取锁但失败，则线程被包装成一个Node结点入队</span>    selfInterrupt();&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;    Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);    <span class="hljs-comment">// 此处为了尽快将结点入队，会首先尝试将当前置为tail，如果未成功的话再执行 enq 方法</span>    Node pred = tail;    <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;      node.prev = pred;      <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;        pred.next = node;        <span class="hljs-keyword">return</span> node;      &#125;    &#125;    enq(node);    <span class="hljs-keyword">return</span> node;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;    <span class="hljs-comment">// 采用自旋的方式入队，此处注意到通过[new Node()]先设置一个逻辑结点来保证队列中至少有一个结点，用来表明此刻已有线程获得锁(不然也到不了这一步)，即head表示占有锁的线程</span>    <span class="hljs-keyword">for</span> (;;) &#123;      Node t = tail;      <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// Must initialize</span>        <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))          tail = head;      &#125; <span class="hljs-keyword">else</span> &#123;        node.prev = t;        <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;          t.next = node;          <span class="hljs-keyword">return</span> t;        &#125;      &#125;    &#125;&#125;</code></pre><p>在非公平锁的acquire方法中，作者尝试以一种独占且忽略中断的方式来获取锁(<a href="http://www.infoq.com/cn/articles/java-interrupt-mechanism" target="_blank" rel="noopener"><strong>什么是Java线程的中断机制，见详细分析Java中断机制</strong></a>，而acquireQueued方法中会保证忽视中断(系统中其它线程可能会对词现场发出中断指令，为了线程能按照正常流程获取锁需要忽略)，在acquireQueued内部通过tryAcquire反复尝试获取锁直到成功，线程也可能由于获取锁失败而反复的被阻塞和唤醒。</p><p>入队的一般步骤：</p><ol><li>先尝试以尾插法的模式将Node入队，但当有其他节点进行插入的时候就会导致compareAndSetHead失败</li><li>compareAndSetHead失败则在enq方法中进行自旋方式进行尾插入队直至成功</li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;      <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-keyword">final</span> Node p = node.predecessor();        <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;          setHead(node);          p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>          failed = <span class="hljs-keyword">false</span>;          <span class="hljs-keyword">return</span> interrupted;        &#125;        <span class="hljs-comment">/** </span><span class="hljs-comment">        * 执行下面流程当且仅当 p != head 或者 p == head但是tryAcquire失败了，那么</span><span class="hljs-comment">        * 在shouldParkAfterFailedAcquire会去检查前继的waitStaus是否为SIGNAL，</span><span class="hljs-comment">        * 因为CLH的特性要求结点必须由其前继唤醒，因而为了保证结点在</span><span class="hljs-comment">        * 阻塞后还能继续被唤醒反复竞争锁，需要检测并最终将前继结点waitStaus置为SIGNAL</span><span class="hljs-comment">        */</span>        <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;            parkAndCheckInterrupt())          <span class="hljs-comment">// 一个线程解除阻塞状态只有两种可能：前继unpark或线程被中断</span>          <span class="hljs-comment">// 线程被中断之后会继续走到if处去判断，也就是会忽视中断，但需要保留中断状态并返回到上级调用者</span>          interrupted = <span class="hljs-keyword">true</span>;      &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;      <span class="hljs-keyword">if</span> (failed)        cancelAcquire(node);    &#125;&#125;</code></pre><p>可以看出线程获取锁是一个自旋的过程，当且仅当当前节点的前驱节点是头结点并且成功获得同步状态时才能跳出循环，之前则会陷入阻塞直至前驱节点唤醒</p><h3 id="共享模式-以CountDownLatch为例"><a href="#共享模式-以CountDownLatch为例" class="headerlink" title="共享模式(以CountDownLatch为例)"></a>共享模式(以CountDownLatch为例)</h3><blockquote><p>CountDownLatch作为一个多用途<strong>(versatile)</strong>基础同步工具，内部通过一个计数器<strong>(不可重用)</strong>来维护一组线程的同步状态。在计数器归零之前，调用 await 方法将会使得多个线程阻塞。一般而言，其主要作用：</p><ol><li>通过latch一个或多个线程等待其它线程操作完成后才进行接下来的操作(线程中断除外)</li><li>将任务进行拆分并分发到不同的线程中完成(考虑用线程池管理)</li></ol></blockquote><p>分析AQS的共享模式，发现第一步同样市尝试获取锁，如果没有成功的话就入队:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><span class="hljs-function">       <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;  <span class="hljs-comment">// 这个Node.SHARED仔细看与独占模式最大的不同是全局共享对象，当一个闭锁对象调用await方法时</span>  <span class="hljs-comment">// 当前调用线程将与这个全局唯一的Node对象关联起来(独占模式没有关联具体Node，一个线程就是一个Node)并一起入队</span>  <span class="hljs-comment">// 这样设计的目的就是需要所有在队列中并处于共享模式的结点都能尽快在第一时间内被唤醒</span>       <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);       <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;       <span class="hljs-keyword">try</span> &#123;           <span class="hljs-keyword">for</span> (;;) &#123;               <span class="hljs-keyword">final</span> Node p = node.predecessor();               <span class="hljs-keyword">if</span> (p == head) &#123;                 <span class="hljs-comment">// 获取锁的过程在CountDownLatch中就是检查计数器(state变量)是否归零</span>                 <span class="hljs-comment">// 这个state变量在不同的并发集合下有不同的含义，比如ReentrantLock中，表示加锁的次数</span>                   <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);                 <span class="hljs-comment">// 头结点获取锁成功，需要唤醒后继结点</span>                   <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;                       setHeadAndPropagate(node, r);                       p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>                       failed = <span class="hljs-keyword">false</span>;                       <span class="hljs-keyword">return</span>;                   &#125;               &#125;               <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                   parkAndCheckInterrupt())                   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();           &#125;       &#125; <span class="hljs-keyword">finally</span> &#123;           <span class="hljs-keyword">if</span> (failed)               cancelAcquire(node);       &#125;   &#125;</code></pre><pre><code>仔细分析一下可以发现，CountDownLatch的共享模式是通过 getState() 方法实现的，而这个方法的调用往往实在不同的线程中执行，每个线程都会检测state变量是否归零，state在某种意义上承担了共享锁的职责。</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> propagate)</span> </span>&#123;        Node h = head; <span class="hljs-comment">// Record old head for check below</span>        setHead(node);        <span class="hljs-comment">/*</span><span class="hljs-comment">         * 在唤醒后继结点的过程中，需要满足以下状况：</span><span class="hljs-comment">         *  1. 前一个结点获取许可成功</span><span class="hljs-comment">         *  2. 之前的操作将此结点的waitStatus设为PROPAGATE，SIGNAL</span><span class="hljs-comment">         *  3. 其它某些未知因素导致的结点为 null</span><span class="hljs-comment">         *  当然，最主要的还是要保证该结点一定始终处于共享状态</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||            (h = head) == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;            Node s = node.next;            <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.isShared())              <span class="hljs-comment">// 不管是共享还是独占只有结点状态为SIGNAL才尝试唤醒后继结点</span>              <span class="hljs-comment">// 释放过程需要检查是否有其他线程也在尝试唤醒(通过头结点的变化)</span>              <span class="hljs-comment">// 长循环的目的主要用于可以释放新加入的结点</span>                doReleaseShared();        &#125;    &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">for</span> (;;) &#123;        Node h = head;        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;          <span class="hljs-keyword">int</span> ws = h.waitStatus;          <span class="hljs-comment">// 检查为SIGNAL表明自身被唤醒同时需要唤醒后继结点并重置其状态(避免重复唤醒)</span>          <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;            <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))              <span class="hljs-keyword">continue</span>;                        unparkSuccessor(h);          &#125;          <span class="hljs-comment">// 在多线程环境下呼应上一个if条件，在前继结点状态重置成功后要将需要唤醒的状态传给下一结点</span>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;                   !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))            <span class="hljs-keyword">continue</span>;                        &#125;        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span>          <span class="hljs-keyword">break</span>;      &#125;   &#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>AQS 实际上并不关心当前是什么锁(那是其子类需要关心的)，对于AQS来说它只是实现了一系列的用于判断“资源”是否可以访问的API，并且封装了在“访问资源”受限时将请求访问的线程的加入队列、挂起、唤醒等操作。ReentrantLock实现的独占锁主要通过 state 是否为0或者当前线程是否已经持有锁(实现可重入的特性)，再将不合条件的线程挂起，入队；而CountDownLatch则只考虑state是否为0(计数器归零)</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发框架</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有序的HashMap-LinkedHashMap</title>
    <link href="/2016/09/03/%E6%9C%89%E5%BA%8F%E7%9A%84HashMap-LinkedHashMap/"/>
    <url>/2016/09/03/%E6%9C%89%E5%BA%8F%E7%9A%84HashMap-LinkedHashMap/</url>
    
    <content type="html"><![CDATA[<p>​    LinkedHashMap作为一个可以按插入顺序遍历的Map集合，在许多功能上和HashMap是重叠，这也难怪，谁叫LinkedHashMap是HashMap的子类。不仅如此，LinkedHashMap还可以根据近期访问某个键值对的顺序（从近期访问最少到近期访问最多的顺序）来遍历元素，这可让需要利用LRU方法进行缓存结果的用户提供一个新的解决方案。</p><hr><p>LinkedHashMap中有一个核心元素：</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>.<span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;      Entry&lt;K,V&gt; before, after;      Entry(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;          <span class="hljs-keyword">super</span>(hash, key, value, next);      &#125;  &#125;</code></pre><pre><code>熟悉LinkedList的人都看出来这是一个用于构造双向链表的结点元素，其中before，after结点分别代表当前entry的前后结点，它是和其父类Node关联起来，一个Entry对应一个Node 先看看下面的程序：</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      LinkedHashMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();      map.put(<span class="hljs-string">"2"</span>, <span class="hljs-number">1</span>);      map.put(<span class="hljs-string">"1"</span>, <span class="hljs-number">2</span>);      map.put(<span class="hljs-string">"0"</span>, <span class="hljs-number">3</span>);      map.put(<span class="hljs-string">"2"</span>, <span class="hljs-number">12</span>);      map.put(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);      Set&lt;Map.Entry&lt;String, Integer&gt;&gt; keys = map.entrySet();      <span class="hljs-keyword">for</span> (Map.Entry entry : keys)          System.out.println(<span class="hljs-string">"key: "</span> + entry.getKey() + <span class="hljs-string">" value: "</span> + entry.getValue());  &#125;</code></pre><p>接下来的是结果：</p><blockquote><p>key: 2 value: 12<br>key: 1 value: 2<br>key: 0 value: 3<br>key: null value: null</p></blockquote><p>拜托，这样的程序还需要演示一遍-_-#<br>断点跟踪一下，发现put方法在LinkedHashMap中是没有重写，而是直接用了HashMap的put方法((+﹏+)~狂晕,那还怎么保证有序的插入，毕竟大家都知道HashMap中的元素是按hash值以及是否冲突来确定位置的)…too young too navie, Api的编写者还会玩套路，跟进putVal方法：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;     <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)         n = (tab = resize()).length;     <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)         tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);     <span class="hljs-keyword">else</span> &#123;         Node&lt;K,V&gt; e; K k;         <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;             ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))             e = p;         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);         <span class="hljs-keyword">else</span> &#123;             <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;                 <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;                     p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);                     <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>                         treeifyBin(tab, hash);                     <span class="hljs-keyword">break</span>;                 &#125;                 <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                     ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))                     <span class="hljs-keyword">break</span>;                 p = e;             &#125;         &#125;         <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span>             V oldValue = e.value;             <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)                 e.value = value;             afterNodeAccess(e);             <span class="hljs-keyword">return</span> oldValue;         &#125;     &#125;     ++modCount;     <span class="hljs-keyword">if</span> (++size &gt; threshold)         resize();     afterNodeInsertion(evict);     <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; &#125;</code></pre><p>先瞄准这一行：tab[i] = newNode(hash, key, value, null);在LinkedHashMap内部重写newNode方法，而且在LinkedHashMap中并没有调用它，看来是准备在这里用啊！</p><pre><code class="hljs java"><span class="hljs-function">Node&lt;K,V&gt; <span class="hljs-title">newNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;       LinkedHashMap.Entry&lt;K,V&gt; p =           <span class="hljs-keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);       linkNodeLast(p);       <span class="hljs-keyword">return</span> p;   &#125;        <span class="hljs-comment">// link at the end of list</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">linkNodeLast</span><span class="hljs-params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;       LinkedHashMap.Entry&lt;K,V&gt; last = tail;       tail = p;       <span class="hljs-keyword">if</span> (last == <span class="hljs-keyword">null</span>)           head = p;       <span class="hljs-keyword">else</span> &#123;           p.before = last;           last.after = p;       &#125;   &#125;</code></pre><pre><code>很熟悉的代码，在一个双向链表中插入一个结点，用于保证LinkedHashMap有序访问元素，就不用多加说明了。 然后再看到后面的 afterNodeAccess(e)和afterNodeInsertion(evict)，随便跟一个进去： </code></pre><pre><code class="hljs java"><span class="hljs-comment">// Callbacks to allow LinkedHashMap post-actions</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeRemoval</span><span class="hljs-params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</code></pre><pre><code>最后来了这么一手，这三个方法在HashMap中时没什么意义的，它主要由其子类LinkedHashMap来添加访问结点后的一些动作，接着进入LinkedHashMap中：</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="hljs-comment">// move node to last</span>       LinkedHashMap.Entry&lt;K,V&gt; last;       <span class="hljs-keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;           <span class="hljs-comment">//将结点e的前后元素暂存，同时将p指向e</span>           LinkedHashMap.Entry&lt;K,V&gt; p =               (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;           p.after = <span class="hljs-keyword">null</span>;           <span class="hljs-comment">//e无前置元素</span>           <span class="hljs-keyword">if</span> (b == <span class="hljs-keyword">null</span>)               head = a;           <span class="hljs-keyword">else</span>               b.after = a;           <span class="hljs-comment">//e无后置元素</span>           <span class="hljs-keyword">if</span> (a != <span class="hljs-keyword">null</span>)               a.before = b;           <span class="hljs-keyword">else</span>               last = b;           <span class="hljs-comment">//链表无元素</span>           <span class="hljs-keyword">if</span> (last == <span class="hljs-keyword">null</span>)               head = p;           <span class="hljs-keyword">else</span> &#123;               p.before = last;               last.after = p;           &#125;           tail = p;           ++modCount;       &#125;   &#125;</code></pre><p>重点先关一下这个accessOrder变量，之前曾经提到过LinkedHashMap可以根据近期对某一个元素的访问顺序来进行排序，类似于LRU算法，而这个结点e可以认为是在插入结点时某个待比较的元素，它可以是链表中任意一个元素(包括新插入的元素)，每次插入元素，e就相当于被访问一次(当然，通过get方法获取元素也相当于访问一次)，在LinkedHashMap中就要移动到最后一个位置，在拿之前的程序，用另一个构造函数实例化LinkedHashMap对象，结果如下：</p><blockquote><p>key: 1 value: 2<br>key: 0 value: 3<br>key: 2 value: 12</p></blockquote><p>可以看到，最后访问了一次key为”2”的元素导致其向后移动，可见谁最后访问，谁在链表中的位置就越靠后</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadPoolExecutor的原理和设计思想</title>
    <link href="/2016/07/20/ThreadPoolExecutor%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    <url>/2016/07/20/ThreadPoolExecutor%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<p>在多线程编程十分普遍的今天，很多人都在用多线程来尽量榨干CPU的性能。但常规地为每个任务创建线程却有以下不足:</p><blockquote><ol><li>创建线程的消耗较高：线程作为CPU分配时间片的基本单位，较多的线程可能会引起CPU频繁地在不同的线程中切换，以至于CPU没有过多的精力来处理任务</li><li>资源消耗大：每创建一个线程的话就会消耗一定的内存资源，当线程数量较大时，CPU就没有过多的精力来处理每一个线程任务，导致线程空占资源，同时给JVM回收线程资源带来较大的压力</li><li>平台相关性：仔细观察源码的话就会发现Java中的Thread类的很多方法都是native的，这表明很多实现都是调用底层的操作系统函数来实现。这让许多的参数，包括JVM参数，栈速配占用的空间大小都受到了平台的线程，如果放到不同平台下可能会导致OOM或栈溢出等问题</li></ol></blockquote><hr><h2 id="初识Executor"><a href="#初识Executor" class="headerlink" title="初识Executor"></a>初识Executor</h2><p>既然线程的创建有这么多不足，Java的设计者就想到了通过一种统一的机制来管理线程，包括其创建，执行和销毁(这和数据库连接池的设计思想类似)，这就是Executor框架下的Executors类。它提供了4种线程池类：</p><ol><li><p>ExecutorService newFixedThreadPool(int nThreads):固定大小线程池</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,                                     <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                                     <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());   &#125;</code></pre></li><li><p>ExecutorService newSingleThreadExecutor()：包含单线程的线程池</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService            (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                                    <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));    &#125;</code></pre></li><li><p>ExecutorService newCachedThreadPool()：带缓存的无界线程池</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,                                      <span class="hljs-number">60L</span>, TimeUnit.SECONDS,                                      <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());    &#125;</code></pre></li></ol><p>具体来说是当空闲线程数量大于核心线程数量(也叫基本线程数量)，该线程池会根据keepAliveTime时间(在此设定为60秒)来决定是否终止多出来的空闲线程，当然如果在这段时间类又有新任务要执行的话就会让这些空闲线程继续执行新任务。</p><p>当然还有一种newScheduledThreadPool线程池，它是一种支持定时或延时执行的计划类线程池，不过它的底层不是基于ThreadPoolExecutor而是ScheduledThreadPoolExecutor(ThreadPoolExecutor子类)来实现<a href="http://www.liuinsect.com/2014/11/17/scheduledthreadpoolexecutor/" target="_blank" rel="noopener">深度解析Java8 – ScheduledThreadPoolExecutor源码解析</a></p><hr><p>上述几种线程池都是由Executors的工厂方法返回的，在很多书上都有介绍它们的基本使用，仔细观察会发现它们都是基于ThreadPoolExecutor实现的，在其JDK文档中这样描述：“ <strong>为了便于跨大量上下文使用，此类提供了很多可调整的参数和扩展钩子 (hook)。但是，强烈建议程序员使用较为方便的 Executors 工厂方法 Executors.newCachedThreadPool()（无界线程池，可以进行自动线程回收）、Executors.newFixedThreadPool(int)（固定大小线程池）和 Executors.newSingleThreadExecutor()（单个后台线程），它们均为大多数使用场景预定义了设置。否则，在手动配置和调整此类时</strong>” 可以看到ThreadPoolExecutor是线程池底层的真正实现，而之前的那几种线程池只是对其做的一层简单封装，其作用在于帮用户预先设置好了某些参数。ThreadPoolExecutor则允许用户更加灵活的配置线程池，包括核心和最大线程数，保持活动时间，如何实现缓存队列，相应的饱和策略，如何配置线程工厂以及对ThreadPoolExecutor的扩展(主要通过重写beforeExecute，afterExecute和terminated方法)</p><hr><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="ctl"><a href="#ctl" class="headerlink" title="ctl"></a>ctl</h3><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));</code></pre><p>这个变量是整个类的核心，AtomicInteger保证了对这个变量的操作是原子的，ThreadPoolExecutor用这一个变量保存了两个内容：</p><ul><li>所有工作线程的数量</li><li>各个线程的状态（runState）</li></ul><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY   = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;   <span class="hljs-comment">// runState is stored in the high-order bits</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING    = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;   <span class="hljs-comment">// Packing and unpacking ctl</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">runStateOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>     </span>&#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>  </span>&#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ctlOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rs, <span class="hljs-keyword">int</span> wc)</span> </span>&#123; <span class="hljs-keyword">return</span> rs | wc; &#125;</code></pre><p>从上面我们可以看到设计者将int变量的低29位存线程数(大约5亿个)，高3位存runState,这样runState有5个值</p><ul><li>RUNNING:接收新的任务，并处理队列中的任务</li><li>SHUTDOWN:不接收新的任务，并处理队列中的任务</li><li>STOP:不接收新的任务，不处理队列中的任务并尝试中断正在执行的任务</li><li>TIDYING：所有任务已终止，工作线程数为0</li><li>TERMINATED：terminated()方法执行完</li></ul><p>其中runStateOf函数用于获取runState的值，上文提到ctl存了线程状态和工作线程数量值，也就是函数中传过来的参数c，CAPACITY的值是<br>00011111111111111111111111111111，取反后为11100000000000000000000000000000，然后进行求与运算取c的值高三位，也就是runState值。<br>对于workerCountOf函数，则是取c的低29位值，也就是workerCount<br>对于ctlOf函数，则是将参数rs(runState)和wc(workerCount)组合成ctl值，也就是说前面两个是从ctl值分离出两个值，这个则是合并</p><p>接下来我们看一下ThreadPoolExecutor提供了哪些参数</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><span class="hljs-function"><span class="hljs-params">                             <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><span class="hljs-function"><span class="hljs-params">                             <span class="hljs-keyword">long</span> keepAliveTime,</span></span><span class="hljs-function"><span class="hljs-params">                             TimeUnit unit,</span></span><span class="hljs-function"><span class="hljs-params">                             BlockingQueue&lt;Runnable&gt; workQueue,</span></span><span class="hljs-function"><span class="hljs-params">                             ThreadFactory threadFactory,</span></span><span class="hljs-function"><span class="hljs-params">                             RejectedExecutionHandler handler)</span></span></code></pre><p>corePoolSize：基本线程数，当线程池没有任务需要处理时能保持的最大空闲线程数<br>maximumPoolSize：线城池的最大线程数，当缓存队列满了后如果当前线程数小于此值就创建新的线程来处理任务<br>keepAliveTime：当线程池中的空闲线程数大于corePoolSize时多出来的线程所允许的最大存活时间，后面的TimeUnit指明时间单位<br>BlockingQueue：用于存放已提交任务的一种缓存队列<br>ThreadFactory：用来创建线程的工厂<br>RejectedExecutionHandler：当缓存队列满了且无法再创建新线程时所要采取的饱和策略</p><p><strong>关于缓存队列的实现策略，有以下三种</strong></p><ol><li>同步提交。缓存队列的默认选项是SynchronousQueue，这种实现策略主要是当要往队列中提交任务时，必须要有一个线程在等待任务执行，当没有线程来接收任务就创建一个线程，通常要求maximumPoolSizes无限大以避免拒绝新提交的任务。另外这种实现策略可以有效避免任务在队列中进行等待，当然你也可以理解为资源数为1，消费者有无数个的消费者-生产者模型，它的主要实现就是之前的newCachedThreadPool</li><li>无界队列。其默认实现就是LinkedBlockingQueue，之前的newSingleThreadExecutor和newFixedThreadPool都是基于此策略来实现缓存队列。这种无界队列在任务提交较为迅速时能避免创建线程，但队列的持续性快速增长仍会带来性能下降的问题，最终只能抑制任务提交以免耗尽内存</li><li>有界队列。可以基于ArrayBlockingQueue实现。基于这种策略的实现往往需要我们在线程数和缓存队列长度中找到一个平衡点，因为队列的有界性，当超出队列长度时只能通过创建新的线程来处理提交的任务，但无限创建线程会耗尽内存，但是通过扩大队列的长度又会导致执行任务的线程数太少，降低系统的吞吐量</li></ol><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;       <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();       <span class="hljs-keyword">int</span> c = ctl.get();       <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;           <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))               <span class="hljs-keyword">return</span>;           c = ctl.get();       &#125;       <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;           <span class="hljs-comment">//任务提交到队列后为防止线程池状态突变，进行双重检查</span>           <span class="hljs-comment">//如果线程池处在非运行下，就要及时移出刚刚入队的任务</span>           <span class="hljs-comment">//并采取饱和策略</span>           <span class="hljs-keyword">int</span> recheck = ctl.get();           <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))               reject(command);           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)           <span class="hljs-comment">//这行代码是为了SHUTDOWN状态下没有活动线程了，但是队列里还有任务没执行这种特殊情况。</span>               addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);       &#125;       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))           reject(command);   &#125;</code></pre><p>此方法用于提交要执行的任务，它主要经历了以下3个步骤：</p><ol><li>如果当前线程数小于corePoolSize数，就直接创建一个线程来执行此任务而不是将其放到缓存队列中</li><li>如果当前线程数大于等于corePoolSize数，当前线程处于运行状态，就尝试将任务放到缓存队列中</li><li>缓存队列满了并且当前线程数不大于maximumPoolSize就创建新的线程来执行任务，否则采取相应的饱和策略来处理</li></ol><p>其中的addWorker难以理解，遂借用别人的理解(o(╯□╰)o)</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;        retry: <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-keyword">int</span> c = ctl.get();            <span class="hljs-keyword">int</span> rs = runStateOf(c);<span class="hljs-comment">// 当前线程池状态</span>            <span class="hljs-comment">// Check if queue empty only if necessary.</span>            <span class="hljs-comment">// 这条语句等价：rs &gt;= SHUTDOWN &amp;&amp; (rs != SHUTDOWN || firstTask != null ||</span>            <span class="hljs-comment">// workQueue.isEmpty())</span>            <span class="hljs-comment">// 满足下列调价则直接返回false，线程创建失败:</span>            <span class="hljs-comment">// rs &gt; SHUTDOWN:STOP || TIDYING || TERMINATED 此时不再接受新的任务，且所有任务执行结束</span>            <span class="hljs-comment">// rs = SHUTDOWN:firtTask != null 此时不再接受任务，但是仍然会执行队列中的任务</span>            <span class="hljs-comment">// rs = SHUTDOWN:firtTask == null见execute方法的addWorker(null,</span>            <span class="hljs-comment">// false)，任务为null &amp;&amp; 队列为空</span>            <span class="hljs-comment">// 最后一种情况也就是说SHUTDONW状态下，如果队列不为空还得接着往下执行，为什么？add一个null任务目的到底是什么？</span>            <span class="hljs-comment">// 看execute方法只有workCount==0的时候firstTask才会为null结合这里的条件就是线程池SHUTDOWN了不再接受新任务</span>            <span class="hljs-comment">// 但是此时队列不为空，那么还得创建线程把任务给执行完才行。</span>            <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span> &amp;&amp; !workQueue.isEmpty()))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// 走到这的情形：</span>            <span class="hljs-comment">// 1.线程池状态为RUNNING</span>            <span class="hljs-comment">// 2.SHUTDOWN状态，但队列中还有任务需要执行</span>            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-keyword">int</span> wc = workerCountOf(c);                <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<span class="hljs-comment">// 原子操作递增workCount</span>                    <span class="hljs-keyword">break</span> retry;<span class="hljs-comment">// 操作成功跳出的重试的循环</span>                c = ctl.get(); <span class="hljs-comment">// Re-read ctl</span>                <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<span class="hljs-comment">// 如果线程池的状态发生变化则重试</span>                    <span class="hljs-keyword">continue</span> retry;                <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span>            &#125;        &#125;        <span class="hljs-comment">// wokerCount递增成功</span>        <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;        Worker w = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;            w = <span class="hljs-keyword">new</span> Worker(firstTask);            <span class="hljs-keyword">final</span> Thread t = w.thread;            <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// 并发的访问线程池workers对象必须加锁</span>                mainLock.lock();                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">// Recheck while holding lock.</span>                    <span class="hljs-comment">// Back out on ThreadFactory failure or if</span>                    <span class="hljs-comment">// shut down before lock acquired.</span>                    <span class="hljs-keyword">int</span> c = ctl.get();                    <span class="hljs-keyword">int</span> rs = runStateOf(c);                    <span class="hljs-comment">// RUNNING状态 || SHUTDONW状态下清理队列中剩余的任务</span>                    <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;                        <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();                        <span class="hljs-comment">// 将新启动的线程添加到线程池中</span>                        workers.add(w);                        <span class="hljs-comment">// 更新largestPoolSize</span>                        <span class="hljs-keyword">int</span> s = workers.size();                        <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)                            largestPoolSize = s;                        workerAdded = <span class="hljs-keyword">true</span>;                    &#125;                &#125; <span class="hljs-keyword">finally</span> &#123;                    mainLock.unlock();                &#125;                <span class="hljs-comment">// 启动新添加的线程，这个线程首先执行firstTask，然后不停的从队列中取任务执行</span>                <span class="hljs-comment">// 当等待keepAlieTime还没有任务执行则该线程结束。见runWoker和getTask方法的代码。</span>                <span class="hljs-keyword">if</span> (workerAdded) &#123;                    t.start();<span class="hljs-comment">// 最终执行的是ThreadPoolExecutor的runWoker方法</span>                    workerStarted = <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">// 线程启动失败，则从wokers中移除w并递减wokerCount</span>            <span class="hljs-keyword">if</span> (!workerStarted)                <span class="hljs-comment">// 递减wokerCount会触发tryTerminate方法</span>                addWorkerFailed(w);        &#125;        <span class="hljs-keyword">return</span> workerStarted;    &#125;</code></pre><h3 id="shutdown和shutdownNow"><a href="#shutdown和shutdownNow" class="headerlink" title="shutdown和shutdownNow"></a>shutdown和shutdownNow</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;      mainLock.lock();      <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">//检查调用者是否具有关闭和中断工作线程权限</span>          checkShutdownAccess();          <span class="hljs-comment">//将线程池状态设为shutdown</span>          advanceRunState(SHUTDOWN);          <span class="hljs-comment">//中断空闲线程</span>          interruptIdleWorkers();          onShutdown(); <span class="hljs-comment">// hook for ScheduledThreadPoolExecutor</span>      &#125; <span class="hljs-keyword">finally</span> &#123;          mainLock.unlock();      &#125;      tryTerminate();  &#125;</code></pre><p>shutdown方法主要是为了阻止任务提交到缓存队列中，但对已提交的任务还是会执行，但是不保证一定执行完，如果有需求的话，可以考虑调用awaitTermination完成</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>&#123;      List&lt;Runnable&gt; tasks;      <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;      mainLock.lock();      <span class="hljs-keyword">try</span> &#123;          checkShutdownAccess();          <span class="hljs-comment">//和shutdown不同，它将线程池状态置为stop</span>          advanceRunState(STOP);          <span class="hljs-comment">//终止所有线程(包括空闲线程和工作线程)</span>          interruptWorkers();          <span class="hljs-comment">//返回队列中还没有被执行的任务</span>          tasks = drainQueue();      &#125; <span class="hljs-keyword">finally</span> &#123;          mainLock.unlock();      &#125;      tryTerminate();      <span class="hljs-keyword">return</span> tasks;  &#125;</code></pre><p>尝试停止所有的活动执行任务、暂停等待任务的处理，并返回等待执行的任务列表。在从此方法返回的任务队列中排空（移除）这些任务。</p><h3 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h3><p>默认的线程工厂实现智能创建一个新的非守护线程，并且不包含任何的配置信息</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ThreadFactory</span> </span>&#123;  <span class="hljs-function">Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span></span>;&#125;</code></pre><p>将要执行的任务封装到一个线程中执行，我们可以通过实现这个接口扩展线程工厂的行为，添加我们想要改变的信息，比如线程名字，优先级之类的</p><h3 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h3><p>之前曾经谈到的，如果在缓存队列已满并且无法创建新的线程来执行新的线程就会启用相应的饱和策略</p><blockquote><ol><li>AbortPolicy：处理程序遭到拒绝将抛出运行时 RejectedExecutionException，也是默认的饱和策略</li><li>DiscardPolicy：不能执行的任务将被删除</li><li>DiscardOldestPolicy：如果执行程序尚未关闭，则位于缓存队列头部的任务将被删除，然后重新执行程序（如果再次失败，则重复此过程）</li><li>CallerRunsPolicy：拒绝新任务的提交，但会在调用execute方法的线程中执行，除非当前线程池关闭，能够减缓新任务的提交速度</li></ol></blockquote><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的讲解，大概可以了解到线程池的一些设计思想，这和数据库连接池的设计有异曲同工的地方。当然，这不是一篇源码分析的文章，没有面面俱到。大致来说线程池的设计思想可以归为以下几点：</p><ul><li>通过corePoolSize来控制工作线程数，以免一开始就创建较多线程来执行，这种思想有点像tcp协议中用慢开始方法进行拥塞控制</li><li>用一个缓存队列将提交的任务进行保存，让有限的线程来得及处理任务</li><li>相应的饱和策略，这种策略可以在无法继续执行任务时提供一种合理的应对措施</li><li>此外灵活的线程工厂可以让用户定制新线程的行为</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li>&lt;&lt;Java并发编程实战&gt;&gt;</li><li><a href="http://www.cnblogs.com/zhanjindong/p/java-concurrent-package-ThreadPoolExecutor.html" target="_blank" rel="noopener">Java并发包源码学习之线程池（一）ThreadPoolExecutor源码分析</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优秀博客链接汇总(长期更新)</title>
    <link href="/2016/06/16/%E4%BC%98%E7%A7%80%E5%8D%9A%E5%AE%A2%E9%93%BE%E6%8E%A5%E6%B1%87%E6%80%BB-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"/>
    <url>/2016/06/16/%E4%BC%98%E7%A7%80%E5%8D%9A%E5%AE%A2%E9%93%BE%E6%8E%A5%E6%B1%87%E6%80%BB-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<p>博主学习新知识的途径主要有以下几种：</p><ol><li>官方文档：这往往是学习一种新知识较为正式且权威的方式(更新速度也是最快的)，毕竟官方出品，必属精品嘛。但有时候描述语言较为抽象且正式，理解起来有时较为晦涩，而且有时候英语会折磨相当一部分人(当然博主还是没什么太大压力的O(∩_∩)O~)</li><li>视频：这种方式往往较为生动，长期学习不容易让人产生烦闷的学习心态。但对知识的掌握较为快餐化，我们只能学到一些表面的东西，比如框架的话往往只能学到如何使用这一层面，对于原理以及设计方面的讲解就较为粗浅</li><li>相关书籍：这也是博主较为常用和喜欢的一种方式，所谓学到老，活到老(不好意思，说反了o(╯□╰)o)，书籍往往在保证知识的系统化的同时也能将知识的讲解下潜到较为深的层次，但缺点是往往更新速度较慢，尤其在这个技术日新月异的IT领域，这个缺点较为明显</li><li>博客：这也是不错的学习途径，博客最大的好处就是即结合了知识的深度，又保证在更新速度上不会太慢。可以说查阅优秀的博文往往可以产生事半功倍的效果(博主的文章就在一直在努力保持不错的水准^_^)。但缺点就是相当一部分的博文没什么水准，且好的博文常常被其他人复制粘贴，关键还不注明出处(╮(╯▽╰)╭…)。当然，除此之外，博文往往带有博主强烈的个人印记和主观色彩，因而对知识的理解上可能会产生偏差</li></ol><hr><p>以下是我搜集到的一些优秀的博客链接，当然有些博文不一定发布在博主的个人博客，有一些开发者社区的文章也是不错的</p><h3 id="Java区"><a href="#Java区" class="headerlink" title="Java区"></a>Java区</h3><ul><li><a href="http://www.ibm.com/developerworks/cn/" target="_blank" rel="noopener">IBM developerWorks</a></li><li><a href="http://ifeve.com/" target="_blank" rel="noopener">并发编程网(方腾飞老师的博客)</a></li><li><a href="http://cmsblogs.com/" target="_blank" rel="noopener">chenssy的博客</a></li><li><a href="http://yihongwei.com/" target="_blank" rel="noopener">小e_鸿伟</a></li><li><a href="http://www.importnew.com/" target="_blank" rel="noopener">ImportNew</a></li><li><a href="http://www.infoq.com/cn" target="_blank" rel="noopener">InfoQ - 促进软件开发领域知识与创新的传播</a></li><li><a href="http://rednaxelafx.iteye.com/" target="_blank" rel="noopener">RednaxelaFX博客 - 原Oracle HotSpot 团队工程师</a></li><li><a href="http://www.liuinsect.com/" target="_blank" rel="noopener">刘锟洋的博客</a></li><li><a href="http://tech.meituan.com/" target="_blank" rel="noopener">美团点评技术团队</a></li><li><a href="http://jm.taobao.org/" target="_blank" rel="noopener">阿里中间件团队博客</a></li><li><a href="http://www.javacui.com/" target="_blank" rel="noopener">java小强的博客</a></li><li><a href="http://it.deepinmind.com/index.html" target="_blank" rel="noopener">deepinmind博客</a></li><li><a href="http://tech.lede.com/" target="_blank" rel="noopener">网易乐得技术团队</a></li></ul><h3 id="Python区"><a href="#Python区" class="headerlink" title="Python区"></a>Python区</h3><ul><li><a href="http://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰的官方网站(python起步教程)</a></li><li><a href="https://www.the5fire.com/" target="_blank" rel="noopener">the5fire的技术博客</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConcurrentLinkedQueue源码分析</title>
    <link href="/2016/06/15/ConcurrentLinkedQueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2016/06/15/ConcurrentLinkedQueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>ConcurrentLinkedQueue作为Doug Lea在JDK5.0推出的又一个并发容器，使用的是基于FIFO的队列结构，在队尾入队，在队首出队，但使用的基于CAS的”wait-free”进行的，也就是线程竞争锁失败后不会挂起，这在一定程度使得线程的等待时间减少，但CAS并不是一个算法，它是一个CPU直接支持的硬件指令，这也就在一定程度上决定了它的平台相关性<br>当前常用的多线程同步机制可以分为下面三种类型：</p><blockquote><ol><li>volatile 变量：轻量级多线程同步机制，不会引起上下文切换和线程调度。仅提供内存可见性保证，不提供原子性。</li><li>CAS 原子指令：轻量级多线程同步机制，不会引起上下文切换和线程调度。它同时提供内存可见性和原子化更新保证。</li><li>互斥锁：重量级多线程同步机制，可能会引起上下文切换和线程调度，它同时提供内存可见性和原子性。<br>注：上下文切换就是CPU在不同线程中分配时间片，在不同线程任务中切换</li></ol></blockquote><p>ConcurrentLinkedQueue 的非阻塞算法实现主要可概括为下面几点：</p><ol><li>使用 CAS 原子指令来处理对数据的并发访问，这是非阻塞算法得以实现的基础。</li><li>head/tail 并非总是指向队列的头 / 尾节点，也就是说允许队列处于不一致状态。 这个特性把入队 / 出队时，原本需要一起原子化执行的两个步骤分离开来，从而缩小了入队 / 出队时需要原子化更新值的范围到唯一变量。这是非阻塞算法得以实现的关键。</li><li>以批处理方式来更新head/tail，从整体上减少入队 / 出队操作的开销。</li></ol><p>在ConcurrentLinkedQueue的源码中，有一段红字规定了的一些基本不变性条件</p><blockquote><ol><li>在入队时最后一个结点中的next域为null</li><li>队列中的所有未删除结点的item域不能为null且从head都可以在O(N)时间内遍历到</li><li>对于要删除的结点，不是将其引用直接置为空，而是将其的item域先置为null(迭代器在遍历是会跳过item为null的结点)</li><li>允许head和tail滞后更新，也就是上文提到的head/tail并非总是指向队列的头 / 尾节点（这主要是为了减少CAS指令执行的次数，但同时会增加volatile读的次数，但是这种消耗较小）。具体而言就是，当在队列中插入一个元素是，会检测tail和最后一个结点之间的距离是否在两个结点及以上(内部称之为hop)；而在出队时，对head的检测就是与队列的第一个结点的距离是否达到两个，有则将head指向第一个结点并将head原来指向的结点的next域指向自己，这样就能断开与队列的联系从而帮助GC</li></ol></blockquote><p><strong>head的不变性和可变性条件</strong></p><blockquote><p>不变性：</p><ol><li>所有未删除节点，都能从head通过调用succ()方法遍历可达。</li><li>head不能为null。</li><li>head节点的next域不能引用到自身。</li></ol><p>可变性：</p><ol><li>head节点的item域可能为null，也可能不为null。</li><li>允许tail滞后（lag behind）于head，也就是说：从head开始遍历队列，不一定能到达tail。</li></ol></blockquote><p><strong>tail的不变性和可变性条件</strong></p><blockquote><p>不变性：</p><ol><li>通过tail调用succ()方法，最后节点总是可达的。</li><li>tail不能为null。</li></ol><p>可变性：</p><ol><li>tail节点的item域可能为null，也可能不为 null。</li><li>允许tail滞后于head，也就是说：从head开始遍历队列，不一定能到达tail。</li><li>tail节点的next域可以引用到自身。</li></ol></blockquote><p><strong>初始化</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentLinkedQueue</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//将head和tail的item和next域置为null    head = tail = new Node&lt;E&gt;(null);&#125;</span></code></pre><p><strong>入队操作</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span> </span><span class="hljs-function"></span>&#123;     checkNotNull(e);     <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;E&gt;(e);     <span class="hljs-keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;)   <span class="hljs-comment">//1</span>     &#123;         Node&lt;E&gt; q = p.next;         <span class="hljs-keyword">if</span> (q == <span class="hljs-keyword">null</span>)<span class="hljs-comment">//2</span>         &#123;             <span class="hljs-keyword">if</span> (p.casNext(<span class="hljs-keyword">null</span>, newNode)) <span class="hljs-comment">//3</span>             &#123;                 <span class="hljs-keyword">if</span> (p != t)<span class="hljs-comment">//4</span>                     casTail(t, newNode);                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;             &#125;         &#125;         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)<span class="hljs-comment">//5</span>             p = (t != (t = tail)) ? t : head;          <span class="hljs-keyword">else</span>             p = (p != t &amp;&amp; t != (t = tail)) ? t : q;<span class="hljs-comment">//6</span>     &#125; &#125;</code></pre><p>1：对于入队操作，采用失败即重试的方式，直到入队成功 </p><p>2：表明p是最后一个结点 </p><p>3：采用CAS指令修改队列的最后一个结点的next域，从而保证最后一个结点是新插入的结点，同时将p指向这个新结点 </p><p>4：如果插入结点后tail和p距离达到两个结点，则修改tail的指向(失败也没关系)，这里在判断tail为最后一个结点后仍然要判断hop是否达到2主要是为了预防在并发修改下，多个线程同时修改的问题 </p><p>5：根据tail的可变性条件和滞后更新策略，我们知道tail的next域可以引用到自身，在ConcurrentLinkedQueue规定如果tail的next如果指向自己的话，则表明tail现在所在指向的结点已被删除(从head遍历无法到达tail)，那么就要从head开始遍历到所有的未删除结点(这也是上文head的不变性条件保证的)具体看下图：</p><p><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/ConcurrentLinkedQueueOffer.png" srcset="/img/loading.gif" alt=""></p><pre><code>当然，我们还是要判断其他线程是否已经提前修改tail的指向，修改的话就表明tail结点已经更新完毕，没有引用到自身了，就可以直接重新尝试插入了。其实从这我们大致可以揣摩出作者的设计的巧妙部分：即虽然tail有滞后更新策略从而导致无法一次就将结点插入，但结点要想插入的话还是必须要当tail为最后一个结点才行 6：tail未指向尾结点，同时也没有滞后head，就像下图这样： 插入前：</code></pre><p><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/ConcurrentLinkedQueueOffer1.png" srcset="/img/loading.gif" alt=""></p><p>这时候表明tail结点还未更新，但需要事先判断其他线程是否可能抢先插入了一个结点，如下图： 其它线程抢先插入后：</p><p><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/ConcurrentLinkedQueueOffer2.png" srcset="/img/loading.gif" alt=""></p><p>在这种情况下如果插入元素的话导致tail和最后一个结点的距离达到两个,就要更新tail的指向(不得不承认这句代码的简洁性，但还是要吐槽一下，从可读性的角度和JDK6.0的版本比起来实在是难以理解)，并且tail已经指向尾结点，说明下一个结点可以直接将tail赋给p以便重新尝试插入。<br>其实仔细分析的话就可以明白多个if判断表明tail的三种可能状态：</p><blockquote><ol><li>tail滞后于 head。</li><li>tail指向尾结点。</li><li>tail指向非尾结点。</li></ol></blockquote><p><strong>出队操作</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;      restartFromHead:      <span class="hljs-keyword">for</span> (;;)       &#123;          <span class="hljs-keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;)           &#123;              E item = p.item;              <span class="hljs-keyword">if</span> (item != <span class="hljs-keyword">null</span> &amp;&amp; p.casItem(item, <span class="hljs-keyword">null</span>)) <span class="hljs-comment">//1</span>              &#123;                  <span class="hljs-keyword">if</span> (p != h)<span class="hljs-comment">//2</span>                      updateHead(h, ((q = p.next) != <span class="hljs-keyword">null</span>) ? q : p);                  <span class="hljs-keyword">return</span> item;              &#125;              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((q = p.next) == <span class="hljs-keyword">null</span>) <span class="hljs-comment">//3</span>              &#123;                  updateHead(h, p);                  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;              &#125;              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)<span class="hljs-comment">//4</span>                  <span class="hljs-keyword">continue</span> restartFromHead;              <span class="hljs-keyword">else</span><span class="hljs-comment">//5</span>                  p = q;          &#125;      &#125;  &#125;</code></pre><p>1：在获取head结点后，如果item不为null的话将其设为null实现删除头结点(这是一个特殊的删除策略，即item为null的结点就是已经删除的结点，即使它还在队列中）</p><p><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/ConcurrentLinkedQueuePoll1.png" srcset="/img/loading.gif" alt=""></p><p>2：删除该结点后检查head是否与头结点相差两个结点，有则向后推进一个item非null结点来更新head <img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/ConcurrentLinkedQueuePoll2.png" srcset="/img/loading.gif" alt=" "></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateHead</span><span class="hljs-params">(Node&lt;E&gt; h, Node&lt;E&gt; p)</span> </span>&#123;     <span class="hljs-comment">// 如果两个结点不相同，尝试用CAS指令原子更新head指向新头节点</span>     <span class="hljs-keyword">if</span> (h != p &amp;&amp; casHead(h, p))      <span class="hljs-comment">//将旧的头结点指向自身以实现删除</span> h.lazySetNext(h);&#125;</code></pre><p>3：head的item为null则向后选取一个结点，如果item为null的结点，设置head指向p节点（此时队列没有元素，只有一个伪结点p） 4：结点出队失败，重新进行出队(关于p == q的判断条件我是在有点难以理解，在此只能作一个不负责任的猜测：就是上一次判断先执行了步骤5，使得p和q指向同一个item不为null的结点，在下一次循环开始前其它线程线程先删除了该结点导致步骤4的发生，这样的话就要重新获取head进行删除) A线程执行步骤5后(为了方便没有画出tail，<strong>再次声明，只是个人观点</strong>)： <a href="http://7xti77.com1.z0.glb.clouddn.com/ConcurrentLinkedQueuePoll3.png" target="_blank" rel="noopener"><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/ConcurrentLinkedQueuePoll3.png" srcset="/img/loading.gif" alt="img"></a> </p><p>B线程抢先删除结点后A线程执行步骤4：<br><a href="http://7xti77.com1.z0.glb.clouddn.com/ConcurrentLinkedQueuePoll4.png" target="_blank" rel="noopener"><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/ConcurrentLinkedQueuePoll4.png" srcset="/img/loading.gif" alt="img"></a><br>5：在结点出队失败后可以保证下次尝试出队时p不为空(之前q = p.next ！= null才有可能跳到这一步)</p><p>根据head的不变性和可变性条件，在执行出队操作前，head在队列中的位置共有两种可能：</p><blockquote><ol><li>head指向有效结点(从head向后遍历可达的结点当中，item域不为null的结点)</li><li>head指向无效结点(从head向后遍历可达的结点当中，item域为null的结点)</li></ol></blockquote><p><strong>队列判空</strong><br>有些人在判断队列是否为空时喜欢用</p><blockquote><p>queue.size()==0</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;     <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;     <span class="hljs-keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="hljs-keyword">null</span>; p = succ(p))         <span class="hljs-keyword">if</span> (p.item != <span class="hljs-keyword">null</span>)             <span class="hljs-comment">// Collection.size() spec says to max out</span>             <span class="hljs-keyword">if</span> (++count == Integer.MAX_VALUE)                 <span class="hljs-keyword">break</span>;     <span class="hljs-keyword">return</span> count; &#125;</code></pre><p>在计算队列的长度是并没有向我们往常一样直接通过一个变量来存储，这样主要是要尽可能保证队列在并发访问下的数据的正确性，但由于遍历时还是会有其它线程对队列的状态进行修改，因而数据仍有可能错误(removeAll,retainAll,containsAll,equals,toArray也有一样的问题)<br>可以看到这样在队列在结点较多时会依次遍历所有结点，这样的性能会有较大影响，因而可以考虑empty函数，它只要判断第一个结点(注意不一定是head指向的结点)</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> first() == <span class="hljs-keyword">null</span>;&#125;</code></pre><p><strong>最后</strong><br>ConcurrentLinkedQueue的迭代器是弱一致性的，这在并发容器中是比较普遍的现象，主要是指在一个线程在遍历队列结点而另一个线程尝试对某个队列结点进行修改的话不会抛出ConcurrentModificationException，这也就造成在遍历某个尚未被修改的结点时，在next方法返回时可以看到该结点的修改，但在遍历后再对该结点修改时就看不到这种变化。特别注意的是ConcurrentLinkedQueue提供的线程安全操作只是相对安全的，即只对单个函数调用所涉及的操作提供安全性</p><hr><p><strong>参考资料</strong></p><ul><li><p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-concurrent/index.html" target="_blank" rel="noopener">非阻塞算法在并发容器中的实现</a></p></li><li><p><a href="http://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf" target="_blank" rel="noopener">ConcurrentLinkedQueue实现的算法理论基础</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于红黑树学习的几点理解</title>
    <link href="/2016/05/23/%E5%85%B3%E4%BA%8E%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%87%A0%E7%82%B9%E7%90%86%E8%A7%A3/"/>
    <url>/2016/05/23/%E5%85%B3%E4%BA%8E%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%87%A0%E7%82%B9%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<pre><code>最近又重温了一下&lt;&lt;算法&gt;&gt;(第四版)这本书关于红黑树的那一章，不得不说从代码简洁性和讲解的通俗性来说，比网上讲红黑树的大多数博客都要好，但对于删除这一难点又没讲得很详细了(不知道作者为什么这么做)</code></pre><hr><p>在讲红黑树的时候，作者先引入了2-3树的概念，也就是包含2-结点(即我们常见的包含左右子结点的结点)和3-结点(除左右结点外还允许在中间在插入一个结点)<br>对于红黑树的定义，作者用了红链接和黑链接的概念，所谓结点的链接可以理解为任意一个结点上方链接的颜色，红链接就是具备了红结点的性质，黑链接就是备了黑结点的性质。</p><p>3-结点<br><a href="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/3-.png" target="_blank" rel="noopener"><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/006HiYd9ly1g09qr51rfcj30b007kdft.jpg" srcset="/img/loading.gif" alt="img"></a> </p><p>2-结点</p><p> <a href="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/2-.png" target="_blank" rel="noopener"><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/006HiYd9ly1g09qr51prcj30c907qaa0.jpg" srcset="/img/loading.gif" alt="img"></a></p><p>为了保证平衡性，定义了以下规则：</p><ol><li>任意一条红链接都是左链接</li><li>任意一个结点都不可以通融同时与两条红链接相连</li><li>任意一个根结点到叶结点锁经过的黑链接数量相同</li></ol><p><strong>旋转</strong><br>定义了一种复合上述要求的Node结点</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> RED = <span class="hljs-keyword">true</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> BLACK = <span class="hljs-keyword">false</span>;<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">Key</span>, <span class="hljs-title">Value</span>&gt;</span><span class="hljs-class"></span>&#123;    Key k;    Value val;    <span class="hljs-keyword">boolean</span> color;    Node left;    Node right;&#125;</code></pre><p>一旦插入元素后，就会多出一条红链接，可能会打破1和3条件，因而必须要通过适当的旋转来维护这种平衡性。主要分为左旋和右旋</p><p> 左旋：</p><p> <img src="https://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/rotateLeft.gif" srcset="/img/loading.gif" alt="左旋"></p><p> <img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/006HiYd9ly1g09qr56nzhj30ej0dn3ys.jpg" srcset="/img/loading.gif" alt="img"></p><p>代码如下： </p><pre><code class="hljs java"><span class="hljs-function">Node <span class="hljs-title">ratoteLeft</span><span class="hljs-params">(Node h)</span></span><span class="hljs-function"></span>&#123;    Node x = h.right;    h.right = x.left;    x.left = h;    x.color = h.color;    h.collor = RED;&#125;</code></pre><p>右旋：<br><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/rotateRight.gif" srcset="/img/loading.gif" alt="右旋"><br><a href="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/rightsample.png" target="_blank" rel="noopener"><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/006HiYd9ly1g09qr5ff8yj30e70blmxc.jpg" srcset="/img/loading.gif" alt="img"></a><br>代码如下：</p><pre><code class="hljs java"><span class="hljs-function">Node <span class="hljs-title">ratoteRight</span><span class="hljs-params">(Node h)</span></span><span class="hljs-function"></span>&#123;    Node x = h.left;    h.left = x.right;    x.right = h;    x.color = h.color;    h.collor = RED;&#125;</code></pre><p><strong>插入</strong><br>插入操作是一个综合性的操作，在插入结点后需要进行适当的转换以维护其平衡性。对于插入操作而言，主要分为对2-结点的插入以及对3-结点的插入</p><p>(1). 2-结点<br>对于2-结点的话，主要分为在其左边还是右边插入，如果在左边插入的话，不会破坏平衡性，因为2-结点的链接为红色；在右边插入的话，则需要进行左旋<br>(2). 3-结点<br>对于3-结点的插入的话，需要分清楚是在左边，中间还是右边插入</p><pre><code class="hljs plain">1. 对于在右边插入的结点，因为父结点的左右子结点都是红链接，因而只要将两个子结点的红链接变黑就行2. 对于在左边插入的结点，则需要先将插入结点的祖父结点进行左旋，然后执行1中的步骤3. 对于在中间插入的结点，需要将插入结点进行右旋，再进行左旋，最后执行步骤1.</code></pre><p><a href="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/rbtreeinsert.png" target="_blank" rel="noopener"><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/006HiYd9ly1g09qr5g3ltj310g0d0wfh.jpg" srcset="/img/loading.gif" alt="img"></a></p><p>关于链接颜色的转变</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flipColors</span><span class="hljs-params">(Node h)</span></span><span class="hljs-function"> </span>&#123;     <span class="hljs-comment">// h must have opposite color of its two children</span>     <span class="hljs-comment">// assert (h != null) &amp;&amp; (h.left != null) &amp;&amp; (h.right != null);</span>     <span class="hljs-comment">// assert (!isRed(h) &amp;&amp;  isRed(h.left) &amp;&amp;  isRed(h.right))</span>     <span class="hljs-comment">//    || (isRed(h)  &amp;&amp; !isRed(h.left) &amp;&amp; !isRed(h.right));</span>     h.color = RED;     h.left.color = BLACK;     h.right.color = BLACK; &#125;</code></pre><p>有了上面的铺垫，插入的代码就显得十分简洁，让人充分感受到简洁代码的美感</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Key key, Value val)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"first argument to put() is null"</span>);    <span class="hljs-keyword">if</span> (val == <span class="hljs-keyword">null</span>)    &#123;        delete(key);        <span class="hljs-keyword">return</span>;    &#125;    root = put(root, key, val);    root.color = BLACK;    <span class="hljs-comment">// assert check();</span>&#125;<span class="hljs-comment">// insert the key-value pair in the subtree rooted at h</span><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">put</span><span class="hljs-params">(Node h, Key key, Value val)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (h == <span class="hljs-keyword">null</span>)    <span class="hljs-keyword">return</span> 一个新结点;    <span class="hljs-comment">//先查找待插入结点的位置</span>    <span class="hljs-keyword">int</span> cmp = key.compareTo(h.key);    <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>)    h.left = put(h.left, key, val);    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>)     h.right = put(h.right, key, val);    <span class="hljs-keyword">else</span>    h.val = val;    <span class="hljs-comment">// 调整链接位置以保持平衡，最后一步也就是上述在3-结点</span>    <span class="hljs-comment">//插入的第一种情况，无论在哪种情况下都会执行</span>    <span class="hljs-comment">//而对于在2-结点中插入的第二种</span>    <span class="hljs-keyword">if</span> (isRed(h.right) &amp;&amp; !isRed(h.left))    h = rotateLeft(h);    <span class="hljs-keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.left.left))    h = rotateRight(h);    <span class="hljs-keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.right))    flipColors(h);    <span class="hljs-comment">//最后将结点数+1</span>    <span class="hljs-keyword">return</span> h;&#125;</code></pre><p>这些笔记主要针对插入操作，如果以后看懂删除再来补充</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>String,StringBuilder和StringBuffer比较</title>
    <link href="/2016/05/19/String-StringBuilder%E5%92%8CStringBuffer%E6%AF%94%E8%BE%83/"/>
    <url>/2016/05/19/String-StringBuilder%E5%92%8CStringBuffer%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<p>说起Java的字符串处理，不得不提API中的字符串三剑客：String,StringBuilder和StringBuffer。很多人一定都使用过这三者(或其中几个)，但从源码的角度，我想以一种更加细致的角度来讲述它们的区别。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>开篇先来讲述String，它也是后面两个的基础。</p><p>不变性</p><p>String作为最知名的不可变，不可继承对象(主要怕破坏其不变性，基本所有的不可变对象都不可继承)：在初始化后其值就不可更改，如果企图对其进行修改的话，会重新创建一个String对象，并将原来的String对象指向新对象，具体的话以下列的程序来讲解：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function"></span>&#123;   String s1 = <span class="hljs-string">"java1"</span>;   String s2 = <span class="hljs-string">"java1"</span>;   s1 = s1 + <span class="hljs-string">""</span>;      System.out.println(s1 == s2);&#125;</code></pre><p>结果自然是false</p><blockquote><p>此程序试图修改String对象的值，通过对程序的调试可以发现，其主要经历了以下三个过程<br>1.创建一个StringBuilder对象(其本质是用一个char数组看来储存字符，默认大小是16，String对象内部也是由char数组保存，String讲完后会说明)<br>2.利用创建的StringBuilder对象<strong>分别</strong>将s1和”1”装进StringBuilder数组对象中<br>3.通过封装好的char数组实例化一个新的String对象</p></blockquote><p>但值得注意的是，将上面的程序稍微改改：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function"> </span>&#123;     String s1;     <span class="hljs-keyword">final</span> String s = <span class="hljs-string">""</span>;     String s2 = <span class="hljs-string">"java1"</span>;     s1 = <span class="hljs-string">"java1"</span> + s;     System.out.println(s1 == s2); &#125;</code></pre><p>结果将变成true<br>上面的变化主要使用final关键字修饰了一下String变量。当final变量是基本数据类型以及String类型时，如果在编译期间能知道它的确切值，则编译器会把它当做编译期常量使用。也就是说在用到该final变量的地方，相当于直接访问的这个常量，不需要在运行时确定。更近一步说，java编译器会将到其对应的常量池中查找该对象的引用(基本数据类型是对应的封装类型，String则对应堆中的字符串常量池(从1.7已经移到堆中))</p><p><strong>创建</strong><br>创建字符串的方式很多，归纳起来有三类：<br>(一).使用new关键字创建字符串，比如String s1 = new String(“abc”);<br>(二).直接指定。比如String s2 = “abc”;<br>(三).使用串联生成新的字符串。比如String s3 = “ab” + “c”;<br>第一种会在堆中直接创建一个字符串对象，而第二、三种则会先尝试到常量池查找，没找到才创建。<br>对于new关键字进行字符串对象创建，Java API提供了很多种构造函数，方式更加灵活多变</p><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringBuilder</span></span><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractStringBuilder</span></span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">CharSequence</span></span></code></pre><p>从上可以看出StringBuilder继承AbstractStringBuilder类，它也是StringBuilder实现可变性的关键。至于CharSequence，它提供了字符序列的有序访问，比如charAt方法和subSequence方法。 StringBuilder和String的最大区别就在于其是可变的，并且API与StringBuffer兼容，但不保证线程安全，因而在单线程情况下有更好的性能 StringBuilder的核心函数就是append()和insert()。接下来主要讲解它们。 append()：主要就是对于字符串进行追加操作，无论是调用构造函数还是直接调用append函数，都会直接或间接调用append函数，其底层调用的就是AbstractStringBuilder的append函数</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(CharSequence s)</span> </span>&#123;       <span class="hljs-comment">//s为null，直接在StringBuilder后追加"null"字符串</span>       <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span>)          <span class="hljs-keyword">return</span> appendNull();       <span class="hljs-keyword">int</span> len = str.length();       <span class="hljs-comment">//确定追加后的char数组需不需扩容</span>       ensureCapacityInternal(count + len);       <span class="hljs-comment">//将字符从此字符串复制到目标字符数组，最终调用System.arraycopy，参数有点长</span>       str.getChars(<span class="hljs-number">0</span>, len, value, count);       count += len;       <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;   &#125;       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minimumCapacity)</span> </span>&#123;       <span class="hljs-comment">// overflow-conscious code</span>       <span class="hljs-keyword">if</span> (minimumCapacity - value.length &gt; <span class="hljs-number">0</span>)           expandCapacity(minimumCapacity);   &#125;       <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">expandCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minimumCapacity)</span> </span>&#123;       <span class="hljs-keyword">int</span> newCapacity = value.length * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;       <span class="hljs-keyword">if</span> (newCapacity - minimumCapacity &lt; <span class="hljs-number">0</span>)           newCapacity = minimumCapacity;       <span class="hljs-keyword">if</span> (newCapacity &lt; <span class="hljs-number">0</span>) &#123;           <span class="hljs-keyword">if</span> (minimumCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();           <span class="hljs-comment">//千万注意别到这一步，不然可能要提前进行FullGC(自带stop the world效果)</span>           <span class="hljs-comment">//来挤出这么大的空间来</span>           newCapacity = Integer.MAX_VALUE;       &#125;       value = Arrays.copyOf(value, newCapacity);   &#125;</code></pre><p>对于append函数，还有一个比较隐蔽的性能问题，这主要发生在我的一次编程中(由于IDEA的强大提示功能，看来好的IDE可以在一定程度上帮助程序员发现技术盲区)，看下面一段代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function"></span>&#123;     StringBuilder  sb = <span class="hljs-keyword">new</span> StringBuilder();     sb.append(<span class="hljs-keyword">new</span> Object() + <span class="hljs-string">""</span>);&#125;</code></pre><p>当写出上面那段代码后，IDE提示有性能问题,这主要是因为在调用append过程中由于发现了隐式的类型转换，会存在append函数的链式调用问题，通过源码调试可以发现，其主要经历了以下过程：</p><blockquote><p>1.首先会创建Object对象，将Object对象转换为String对象，并且会第一次调用append函数将其追加进来。<br>2.第二次调用append函数将””放进char数组中，<br>3.将char数组作为参数实例化一个String对象<br>4.第三次调用append函数将String对象追加进来</p></blockquote><p>就因为一个隐式的类型转化，却饶了一大圈，一但将sb.append(new Object() + “”);放在一个循环体里，性能就会受到较大影响，如果非要强转，可以在append之前进行或者调用两次append方法，即sb.append(new Object()).append(“”)</p><p>insert()：相对与append函数只能在字符序列尾部进行插入，insert函数可以指明待插入的位置</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, String str)</span> </span>&#123;       <span class="hljs-keyword">if</span> ((offset &lt; <span class="hljs-number">0</span>) || (offset &gt; length()))           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset);       <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span>)           str = <span class="hljs-string">"null"</span>;       <span class="hljs-keyword">int</span> len = str.length();       ensureCapacityInternal(count + len);       <span class="hljs-comment">//将offset之后的字符保存至[offset + len, count + len]区间</span>       System.arraycopy(value, offset, value, offset + len, count - offset);       <span class="hljs-comment">//中间的len长度保存待插入字符</span>       str.getChars(value, offset);       count += len;       <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;   &#125;</code></pre><p>其insert函数过程大致如上，其重载版本大同小异，无非就是增加类型转换，边界检查的条件不同</p><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>StringBuffer和StringBuilder的最大区别就是是否是线程安全，其手段主要是在StringBuilder的方法用synchronized进行同步，除此之外，它们的API在很多地方是相互兼容的，而和String相比，其作用主要在于对字符串的更改操作(插入和删除)都是对对象本身进行操作，对内存友好。除此之外，StringBuffer内部还提供了一个叫toStringCache的字符缓冲数组，它主要用于保存上一次调用toString方法是保留的字符对象(也就是作为缓冲对象的暂存处)，当我们试图修改字符串的内容是，上一个toStringCache缓冲的内容就会被清除。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综合而言，这三者之间并没有谁比谁优秀的说法，对于不同的应用场景，可以按需求选取，但就我个人而言，对于StringBuffer的实现简单地使用synchronized进行同步来实现线程安全还是不太友好，也希望Java的设计者能找到更好的做法</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LinkedList源码分析(JDK8)</title>
    <link href="/2016/05/13/LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-JDK8/"/>
    <url>/2016/05/13/LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-JDK8/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs java"><span class="hljs-comment">//LinkedList类的关系类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt;</span><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;<span class="hljs-title">E</span>&gt;</span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span></code></pre><p>LinkedList 是一个继承于AbstractSequentialList的双向环状链表。它也可以被当作堆栈、队列或双端队列进行操作<br>LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。<br>LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化<br>LinkedList 是非同步的。</p><p>下面我们来看看LinkedList集合的几个重要属性</p><pre><code class="hljs java"><span class="hljs-comment">//记录list的长度，不可被序列化，因为其未实现Serializable接口(下同)</span><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<span class="hljs-comment">//LinkedList的核心，一个保存相邻结点引用的结点，LinkedList双向遍历的关键，可以将结点的插入指定在list头部插入，初始值为null</span><span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<span class="hljs-comment">//保存最后一个插入结点的位置，初始值为null</span><span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<span class="hljs-comment">//LinkedList核心类，pre保存上一个结点的引用，next保存下一个结点的引用，item是存储结点的数据</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span><span class="hljs-class"></span>&#123;  E item;  Node&lt;E&gt; next;  Node&lt;E&gt; prev;  Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next)  &#123;     <span class="hljs-keyword">this</span>.item = element;     <span class="hljs-keyword">this</span>.next = next;     <span class="hljs-keyword">this</span>.prev = prev;  &#125;&#125;</code></pre><p>其结构可简化为：<img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/006HiYd9ly1g09qr57e37j30tm09gjrh.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>添加结点</strong></p><p> LinkedList一般而言会在尾部插入新结点 原理就是先暂存尾结点，然后创立一个新结点，并将新结点的pre指向尾结点，如果新插入的结点为第一个结点的话，则将其置为首结点</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;       linkLast(e);       <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   &#125;      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkLast</span><span class="hljs-params">(E e)</span> </span>&#123;       <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;       <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(l, e, <span class="hljs-keyword">null</span>);       last = newNode;       <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)           first = newNode;       <span class="hljs-keyword">else</span>           l.next = newNode;       size++;       modCount++;   &#125;</code></pre><p>如下图：</p><p><a href="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/addlistnode.png" target="_blank" rel="noopener"><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/006HiYd9ly1g09qr52v6kj30og0egmxd.jpg" srcset="/img/loading.gif" alt="img"></a></p><p><strong>addAll添加全部某个集合的所有元素作为列表的结点</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;    checkPositionIndex(index);    Object[] a = c.toArray();    <span class="hljs-keyword">int</span> numNew = a.length;    <span class="hljs-keyword">if</span> (numNew == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    Node&lt;E&gt; pred, succ;    <span class="hljs-keyword">if</span> (index == size) &#123;        succ = <span class="hljs-keyword">null</span>;        pred = last;    &#125; <span class="hljs-keyword">else</span> &#123;        succ = node(index);        pred = succ.prev;    &#125;    <span class="hljs-keyword">for</span> (Object o : a) &#123;        <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>) E e = (E) o;        Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(pred, e, <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">if</span> (pred == <span class="hljs-keyword">null</span>)            first = newNode;        <span class="hljs-keyword">else</span>            pred.next = newNode;        pred = newNode;    &#125;    <span class="hljs-keyword">if</span> (succ == <span class="hljs-keyword">null</span>) &#123;        last = pred;    &#125; <span class="hljs-keyword">else</span> &#123;        pred.next = succ;        succ.prev = pred;    &#125;    size += numNew;    modCount++;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><p>添加集合中的元素首先从last开始添加第一个元素，然后依次遍历集合的每一个元素，然后将其依次插入到尾部，当然，你也可以用index属性指定插入到list的某个位置</p><p><strong>get函数</strong><br>获取某个元素最终通过node函数并且指定结点的位置来获取元素，注意这个函数和<strong>public boolean offer(E e)</strong>的区别，除了一个根据下标来获取值，一个用具体的元素来获取值意外，通过get函数来查找元素下标越界的话会抛出异常，而用offer来获取元素当查找一个不存在的元素是只会返回false，这在特定没有处理异常或忘记处理的情况下可以维护程序的稳定运行</p><pre><code class="hljs java"><span class="hljs-function">Node&lt;E&gt; <span class="hljs-title">node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-comment">// assert isElementIndex(index);</span>    <span class="hljs-comment">//因为LinkedList是双向链表，因而对于它的的遍历可以根据</span>    <span class="hljs-comment">//index的值来优化：如若index在list左半部分的话，就从头</span>    <span class="hljs-comment">//开始遍历，否则就从后半部分开始遍历</span>    <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;        Node&lt;E&gt; x = first;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)            x = x.next;        <span class="hljs-keyword">return</span> x;    &#125; <span class="hljs-keyword">else</span> &#123;        Node&lt;E&gt; x = last;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size - <span class="hljs-number">1</span>; i &gt; index; i--)            x = x.prev;        <span class="hljs-keyword">return</span> x;    &#125;&#125;</code></pre><p><strong>clone函数</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//调用Object的函数clone函数返回一个LinkedList对象</span>      LinkedList&lt;E&gt; clone = superClone();      <span class="hljs-comment">// 将克隆对象的成员还原成初始值，以便接下来重新添加元素</span>      clone.first = clone.last = <span class="hljs-keyword">null</span>;      clone.size = <span class="hljs-number">0</span>;      clone.modCount = <span class="hljs-number">0</span>;      <span class="hljs-comment">//将本体的元素一一clone到新对象</span>      <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next)          clone.add(x.item);      <span class="hljs-keyword">return</span> clone;  &#125;</code></pre><p><strong>clear函数</strong></p><p> 这个没什么多说的，依次清除每个元素，并置为null好方便GC</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; ) &#123;        Node&lt;E&gt; next = x.next;        x.item = <span class="hljs-keyword">null</span>;        x.next = <span class="hljs-keyword">null</span>;        x.prev = <span class="hljs-keyword">null</span>;        x = next;    &#125;    first = last = <span class="hljs-keyword">null</span>;    size = <span class="hljs-number">0</span>;    modCount++;&#125;</code></pre><p>关于LinkedList，还有一个比较特别的迭代器DescendingIterator，它是基于双端队列的一个迭代器，允许从后往前开始遍历，并且提供了获取下一个元素以及删除元素的功能。另外值得注意的是由于LinkedList是一个非线程安全的集合，是的它的的迭代器具有fail-fast(快速失效)的特征，具体表现就是不允许多个线程对集合进行修改，也不允许当一个线程遍历元素时，另一个线程对其进行修改，否则会抛出ConcurrentModificationException(并发修改异常)，这是由一个叫modCount的变量控制的，具体在我关于ConcurrentHashMap的博文中也提到了 </p>]]></content>
    
    
    <categories>
      
      <category>集合框架</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ConcurrentHashMap源码解析(基于JDK7)</title>
    <link href="/2016/04/27/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%9F%BA%E4%BA%8EJDK7/"/>
    <url>/2016/04/27/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%9F%BA%E4%BA%8EJDK7/</url>
    
    <content type="html"><![CDATA[<h5 id="JDK8对ConcurrentHashMap做了很大的的改进主要是用CAS算法-非阻塞的无锁算法-代替了分段锁，使得并发的效率进一步提高。但难度也加大了不少-代码激增至6000多行-。无奈网上没有好的讲解，实在无法理解源码。因而只能对JDK7的ConcurrentHashMap作出解释-水平有限，毕竟学生o-╯□╰-o"><a href="#JDK8对ConcurrentHashMap做了很大的的改进主要是用CAS算法-非阻塞的无锁算法-代替了分段锁，使得并发的效率进一步提高。但难度也加大了不少-代码激增至6000多行-。无奈网上没有好的讲解，实在无法理解源码。因而只能对JDK7的ConcurrentHashMap作出解释-水平有限，毕竟学生o-╯□╰-o" class="headerlink" title="JDK8对ConcurrentHashMap做了很大的的改进主要是用CAS算法(非阻塞的无锁算法)代替了分段锁，使得并发的效率进一步提高。但难度也加大了不少(代码激增至6000多行)。无奈网上没有好的讲解，实在无法理解源码。因而只能对JDK7的ConcurrentHashMap作出解释(水平有限，毕竟学生o(╯□╰)o)"></a>JDK8对ConcurrentHashMap做了很大的的改进主要是用CAS算法(非阻塞的无锁算法)代替了分段锁，使得并发的效率进一步提高。但难度也加大了不少(代码激增至6000多行)。无奈网上没有好的讲解，实在无法理解源码。因而只能对JDK7的ConcurrentHashMap作出解释(水平有限，毕竟学生o(╯□╰)o)</h5><hr><pre><code>ConcurrentHashMap的出现主要是用来高效地解决多线程下不同线程对数据的争用问题。在早期，Java为了解决传统HashMap的非线程安全问题是采用的是对每个方法进行synchronized同步(比如HashTable)，而synchronized本质采用了独占锁(也叫悲观锁)的机制，多个线程对数据的访问必须串行化地进行，从而导致多个用户线程进入阻塞，严重影响效率。因而为了尽可能减少阻塞，ConcurrentHashMap就应运而生了 首先来介绍ConcurrentHashMap的几个常量</code></pre><pre><code class="hljs java"><span class="hljs-comment">//哈希表的最大容量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<span class="hljs-comment">//ConcurrentHashMap的负载因子，当哈希表的的长度达到CAPACITY * LOAD_FACTOR时哈希表会扩容</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<span class="hljs-comment">//ConcurrentHashMap的默认容量，要设置为2的指数幂</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">16</span>;<span class="hljs-comment">//分段锁的取值范围,必须为2的指数幂，便于通过键的hash值确定键在哪个区段</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="hljs-number">2</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_SEGMENTS = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">16</span>; <span class="hljs-comment">// slightly conservative</span></code></pre><p>在ConcurrentHashMap中，开创性地使用了<strong>分段锁</strong>的概念，什么是分段锁？看下图：</p><p><a href="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/concurrenthashmap.png" target="_blank" rel="noopener"><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/006HiYd9ly1g09qr5t99aj30nm0mdjte.jpg" srcset="/img/loading.gif" alt="concurrenthashmap.png"></a></p><p>从图中可以看到，ConcurrentHashMap内部分为很多个Segment（继承ReentrantLock），每一个Segment拥有一把锁且管理一个HashEntry数组(本质就是一个哈希表)。对于一个key，需要经过三次hash操作，才能最终定位这个元素的位置，这三次hash分别为：</p><blockquote><p>对于一个key，先进行一次hash操作，得到hash值h1，也即h1 = key.hashCode()（如果key所属类型重写了hashCode方法，就调用具体的hashCode方法）；<br>将得到的h1的高几位与低几位进行异或运算得到hash值h2，也即h2 = hash2(h1高几位),通过h2能够确定该元素的放在哪个Segment；<br>将得到的h1进行第三次hash，得到hash值h3，也即h3 = hash3(h1)，通过h3能够确定该元素放置在哪个HashEntry。</p></blockquote><p>关于为什么确定数据在哪个Segment要进行2次哈希，首先我们来看看JDK的hash函数源码(此函数参与第二次hash)：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* Applies a supplemental hash function to a given hashCode, which</span><span class="hljs-comment">* defends against poor quality hash functions.  This is critical</span><span class="hljs-comment">* because ConcurrentHashMap uses power-of-two length hash tables,</span><span class="hljs-comment">* that otherwise encounter collisions for hashCodes that do not</span><span class="hljs-comment">* differ in lower or upper bits.</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> h = hashSeed;    <span class="hljs-keyword">if</span> ((<span class="hljs-number">0</span> != h) &amp;&amp; (k <span class="hljs-keyword">instanceof</span> String)) &#123;            <span class="hljs-keyword">return</span> sun.misc.Hashing.stringHash32((String) k);        &#125;    h ^= k.hashCode();    <span class="hljs-comment">// Spread bits to regularize both segment and index locations,</span>    <span class="hljs-comment">// using variant of single-word Wang/Jenkins hash.</span>    h += (h &lt;&lt;  <span class="hljs-number">15</span>) ^ <span class="hljs-number">0xffffcd7d</span>;    h ^= (h &gt;&gt;&gt; <span class="hljs-number">10</span>);    h += (h &lt;&lt;   <span class="hljs-number">3</span>);    h ^= (h &gt;&gt;&gt;  <span class="hljs-number">6</span>);    h += (h &lt;&lt;   <span class="hljs-number">2</span>) + (h &lt;&lt; <span class="hljs-number">14</span>);    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);&#125;</code></pre><p>源码中大意说此hash函数是用来解决传统的hash函数所带来的低效问题，因为一旦hash值化为二进制后，由于只与后几位进行位与运算，造成高位的hash值被掩盖从而使得较大数的hash值与较小数的hash值无异，举个例子：</p><pre><code class="hljs java">System.out.println(Integer.parseInt(<span class="hljs-string">"0001111"</span>, <span class="hljs-number">2</span>) &amp; <span class="hljs-number">15</span>);System.out.println(Integer.parseInt(<span class="hljs-string">"0011111"</span>, <span class="hljs-number">2</span>) &amp; <span class="hljs-number">15</span>);System.out.println(Integer.parseInt(<span class="hljs-string">"0111111"</span>, <span class="hljs-number">2</span>) &amp; <span class="hljs-number">15</span>);System.out.println(Integer.parseInt(<span class="hljs-string">"1111111"</span>, <span class="hljs-number">2</span>) &amp; <span class="hljs-number">15</span>);</code></pre><p>由于15只有后四位是全1，因而对于相差32,64,128的数值而言与15的哈希值一样，这样碰撞的几率大增，因而多个线程仍有很大几率访问同一个segment，分段锁的优势也就荡然无存了，但是如果我们先把上例中的二进制数字使用hash()函数先进行一次预hash，得到的结果是这样的：</p><blockquote><p>0100｜0111｜0110｜0111｜1101｜1010｜0100｜1110<br>1111｜0111｜0100｜0011｜0000｜0001｜1011｜1000<br>0111｜0111｜0110｜1001｜0100｜0110｜0011｜1110<br>1000｜0011｜0000｜0000｜1100｜1000｜0001｜1010</p></blockquote><p>默认情况下segmentShift为28，segmentMask为15，再哈希后的数最大是32位二进制数据，向右无符号移动28位，意思是让高4位参与到hash运算中， (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask的运算结果分别是4，15，7和8，可以看到hash值没有发生冲突。ConcurrentHashMap通过以下哈希算法定位segment</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> Segment&lt;K,V&gt; <span class="hljs-title">segmentFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];&#125;</code></pre><p>关于ConcurrentHashMap的<strong>初始化</strong>，有这样一个函数</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity,</span></span><span class="hljs-function"><span class="hljs-params">                           <span class="hljs-keyword">float</span> loadFactor, <span class="hljs-keyword">int</span> concurrencyLevel)</span></span>&#123;      <span class="hljs-keyword">if</span> (!(loadFactor &gt; <span class="hljs-number">0</span>) || initialCapacity &lt; <span class="hljs-number">0</span> || concurrencyLevel &lt;= <span class="hljs-number">0</span>)          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();      <span class="hljs-keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)          concurrencyLevel = MAX_SEGMENTS;      <span class="hljs-comment">// Find power-of-two sizes best matching arguments</span>      <span class="hljs-keyword">int</span> sshift = <span class="hljs-number">0</span>;      <span class="hljs-keyword">int</span> ssize = <span class="hljs-number">1</span>;      <span class="hljs-keyword">while</span> (ssize &lt; concurrencyLevel) &#123;          ++sshift;          ssize &lt;&lt;= <span class="hljs-number">1</span>;      &#125;      <span class="hljs-keyword">this</span>.segmentShift = <span class="hljs-number">32</span> - sshift;      <span class="hljs-keyword">this</span>.segmentMask = ssize - <span class="hljs-number">1</span>;      <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)          initialCapacity = MAXIMUM_CAPACITY;      <span class="hljs-keyword">int</span> c = initialCapacity / ssize;      <span class="hljs-keyword">if</span> (c * ssize &lt; initialCapacity)          ++c;      <span class="hljs-keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;      <span class="hljs-keyword">while</span> (cap &lt; c)          cap &lt;&lt;= <span class="hljs-number">1</span>;      <span class="hljs-comment">// create segments and segments[0]</span>      Segment&lt;K,V&gt; s0 =          <span class="hljs-keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="hljs-keyword">int</span>)(cap * loadFactor),                           (HashEntry&lt;K,V&gt;[])<span class="hljs-keyword">new</span> HashEntry[cap]);      Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Segment[ssize];      UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="hljs-comment">// ordered write of segments[0]</span>      <span class="hljs-keyword">this</span>.segments = ss;  &#125;</code></pre><p>如果在未设置下concurrencyLevel的默认值为<strong>static final int DEFAULT_CONCURRENCY_LEVEL = 16;</strong>，此值也是用来表示segment的数量(不可太大，否则可能有segment存不上值，浪费内存空间，太小的话数据争用仍会比较严重)。循环结束后ssize的值为16，sshift则为4，segmentShift为28，segmentMask为15。而cap这个值为每个Segment平均应该放置多少个元素。其默认值 <strong>static final int MIN_SEGMENT_TABLE_CAPACITY = 2;</strong>表示每个segment对应的HashEntry数组的容量(要求是大于等于c，并且必须为2的指数幂)<br>最后创建一个Segment实例，将其当做Segment数组的第一个元素。</p><p><strong>put操作</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;       Segment&lt;K,V&gt; s;       <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>)           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();       <span class="hljs-keyword">int</span> hash = hash(key.hashCode());       <span class="hljs-keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;       <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="hljs-comment">// nonvolatile; recheck</span>            (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="hljs-keyword">null</span>) <span class="hljs-comment">//  in ensureSegment</span>           s = ensureSegment(j);       <span class="hljs-keyword">return</span> s.put(key, hash, value, <span class="hljs-keyword">false</span>);   &#125;         <span class="hljs-comment">/****   put(K key, int hash, V value, boolean onlyIfAbsent)[是一个Segment方法]   ****/</span>   <span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, <span class="hljs-keyword">int</span> hash, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;HashEntry&lt;K,V&gt; node = tryLock() ? <span class="hljs-keyword">null</span> :scanAndLockForPut(key, hash, value);V oldValue;<span class="hljs-keyword">try</span> &#123;HashEntry&lt;K,V&gt;[] tab = table;           <span class="hljs-comment">//第三次hash</span><span class="hljs-keyword">int</span> index = (tab.length - <span class="hljs-number">1</span>) &amp; hash;           <span class="hljs-comment">//根据hash值找到具体该插入到hash数组的哪个位置</span>HashEntry&lt;K,V&gt; first = entryAt(tab, index);           <span class="hljs-comment">//如果冲突，则遍历线性表</span><span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;<span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;K k;<span class="hljs-keyword">if</span> ((k = e.key) == key ||(e.hash == hash &amp;&amp; key.equals(k))) &#123;oldValue = e.value;<span class="hljs-keyword">if</span> (!onlyIfAbsent) &#123;e.value = value;++modCount;&#125;<span class="hljs-keyword">break</span>;&#125;e = e.next;&#125;               <span class="hljs-comment">//如果插入元素后HashEntry数组长度达到Capacity * loadFactor，</span>                   <span class="hljs-comment">//则进行扩容并根据值的hash重新确定元素在数组中的位置，即rehash(node)</span><span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)node.setNext(first);<span class="hljs-keyword">else</span>node = <span class="hljs-keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);<span class="hljs-keyword">int</span> c = count + <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)rehash(node);<span class="hljs-keyword">else</span>setEntryAt(tab, index, node);++modCount;count = c;oldValue = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125; <span class="hljs-keyword">finally</span> &#123;unlock();&#125;<span class="hljs-keyword">return</span> oldValue;&#125;</code></pre><p>从上面很明显里看出ConcurrentHashMap中的key和value值都不能为null，在进行前两次hash运算后通过<strong>(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask</strong>最终确定数据在哪个segment，然后获得相应的segment对象之后再将其插入到该segment的HashEntry数组的某个位置。比如取hash的高四位(在初始化的时候我们说过segmentShift的值等于32-sshift，例如concurrencyLevel等于16，则sshift等于4，则segmentShift为28。segmentMask为15)</p><p><strong>get操作</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;        Segment&lt;K,V&gt; s; <span class="hljs-comment">// manually integrate access methods to reduce overhead</span>        HashEntry&lt;K,V&gt;[] tab;        <span class="hljs-keyword">int</span> h = hash(key);        <span class="hljs-keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;        <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="hljs-keyword">null</span> &amp;&amp;            (tab = s.table) != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile                     (tab, ((<span class="hljs-keyword">long</span>)(((tab.length - <span class="hljs-number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);                 e != <span class="hljs-keyword">null</span>; e = e.next) &#123;                K k;                <span class="hljs-keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))                    <span class="hljs-keyword">return</span> e.value;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;</code></pre><p>与put操作类似，都是通过key三次hash后确定其在哪个HashEntry，然后从某个HashEntry对象开始遍历寻找(相当于从链表头结点向下遍历),get方法是基于UNSAFE.getObjectVolatile原子操作，没有显示的使用锁（基于乐观锁，即失败就反复尝试），从而提高了吞吐量。这是由于统计当前Segement大小的count字段和用于存储值的HashEntry及其值value定义成volatile关键字修饰的变量，在java内存模型的happens-before规则下，对其写一定要优先于读，保证在多线程情况下，一个线程对值的修改立即对其它线程可见。但值得注意的是get方法是<strong>弱一致</strong>的，也就是你期望往ConcurrentHashMap底层数据结构中加入一个元素后，立马能对get可见，但ConcurrentHashMap并不能如你所愿。换句话说，put操作将一个元素加入到底层数据结构后，get可能在某段时间内还看不到这个元素。具体可参照<a href="http://ifeve.com/concurrenthashmap-weakly-consistent/" target="_blank" rel="noopener">为什么ConcurrentHashMap是弱一致的</a></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* The per-segment table. Elements are accessed via</span><span class="hljs-comment">* entryAt/setEntryAt providing volatile semantics.</span><span class="hljs-comment">*/</span><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;<span class="hljs-comment">/**</span><span class="hljs-comment">* The number of elements. Accessed only either within locks</span><span class="hljs-comment">* or among other volatile reads that maintain visibility.</span><span class="hljs-comment">*/</span><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> count;<span class="hljs-comment">/**********************************************/</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashEntry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;        <span class="hljs-keyword">final</span> K key;        <span class="hljs-keyword">volatile</span> V value;        <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt; next;                HashEntry(<span class="hljs-keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;            <span class="hljs-keyword">this</span>.hash = hash;            <span class="hljs-keyword">this</span>.key = key;            <span class="hljs-keyword">this</span>.value = value;            <span class="hljs-keyword">this</span>.next = next;        &#125;&#125;</code></pre><p><strong>size操作</strong> </p><p>size操作与put和get操作最大的区别在于，size操作需要遍历所有的Segment才能算出整个Map的大小，而put和get都只关心一个Segment。假设我们当前遍历的Segment为SA，那么在遍历SA过程中其他的Segment比如SB可能会被修改，于是这一次运算出来的size值可能并不是Map当前的真正大小。所以一个比较简单的办法就是计算Map大小的时候所有的Segment都Lock住，不能更新(包含put，remove等等)数据，计算完之后再Unlock。这是普通人能够想到的方案，但是牛逼的作者还有一个更好的Idea：先给3次机会，不lock所有的Segment，遍历所有Segment，累加各个Segment的大小得到整个Map的大小，如果某相邻的两次计算获取的所有Segment的更新的次数（每个Segment都有一个modCount变量，这个变量在Segment中的Entry被修改时会加一，通过这个值可以得到每个Segment的更新操作的次数）是一样的，说明计算过程中没有更新操作，则直接返回这个值。如果这三次不加锁的计算过程中Map的更新次数有变化，则之后的计算先对所有的Segment加锁，再遍历所有Segment计算Map大小，最后再解锁所有Segment。源代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// Try a few times to get accurate count. On failure due to</span>        <span class="hljs-comment">// continuous async changes in table, resort to locking.</span>        <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="hljs-keyword">this</span>.segments;        <span class="hljs-keyword">int</span> size;        <span class="hljs-keyword">boolean</span> overflow; <span class="hljs-comment">// true if size overflows 32 bits</span>        <span class="hljs-keyword">long</span> sum;         <span class="hljs-comment">// sum of modCounts</span>        <span class="hljs-keyword">long</span> last = <span class="hljs-number">0L</span>;   <span class="hljs-comment">// previous sum</span>        <span class="hljs-keyword">int</span> retries = -<span class="hljs-number">1</span>; <span class="hljs-comment">// first iteration isn't retry</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; segments.length; ++j)                        ensureSegment(j).lock(); <span class="hljs-comment">// force creation</span>                &#125;                sum = <span class="hljs-number">0L</span>;                size = <span class="hljs-number">0</span>;                overflow = <span class="hljs-keyword">false</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; segments.length; ++j) &#123;                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);                    <span class="hljs-keyword">if</span> (seg != <span class="hljs-keyword">null</span>) &#123;                        sum += seg.modCount;                        <span class="hljs-keyword">int</span> c = seg.count;                        <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">0</span> || (size += c) &lt; <span class="hljs-number">0</span>)                            overflow = <span class="hljs-keyword">true</span>;                    &#125;                &#125;                <span class="hljs-keyword">if</span> (sum == last)                    <span class="hljs-keyword">break</span>;                last = sum;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; segments.length; ++j)                    segmentAt(segments, j).unlock();            &#125;        &#125;        <span class="hljs-keyword">return</span> overflow ? Integer.MAX_VALUE : size;    &#125;</code></pre><p>注意<strong>static final int RETRIES_BEFORE_LOCK = 2;</strong>以及<strong>sum += seg.modCount;</strong>和</p><blockquote><p>if (sum == last)<br>{break;}<br>last = sum;</p></blockquote><p>现在我们假定一共有4个segment，当第一次循环后他们所对应的modCount分别为2，4，4,8。则和为2+4+4+8=18，第二次循环后就变为3，4,5,9，和为3+4+5+9=21,由于与last不相等，故进行第三次循环并将last更新为21，如果第三次比较还与last不相等，那就别怪我太粗鲁了(锁全部segment)，类似的操作还有containsValue方法(containsKey方法则不用这么麻烦，因为key一旦确立则不可更改)</p><p><strong>结语</strong><br>ConcurrentHashMap虽然作为一个相对高效的线程安全类，但其并不能保证使用了ConcurrentHashMap的操作都是线程安全的！很简单，比如用ConcurrentHashMap作两次put操作，只能保证单个put操作的原子性，但两次put操作并没有值依赖关系，依然会受指令重排序的影响(具体涉及Java内存模型的知识，可参照并发编程网的<a href="http://ifeve.com/java-memory-model-0/" target="_blank" rel="noopener">深入理解java内存模型</a>)<br>另外特别感谢<a href="http://qifuguang.me/2015/09/10/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E5%85%AB]%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90ConcurrentHashMap/" target="_blank" rel="noopener">此博文</a>对我的帮助，我的这篇文章借鉴了他的部分观点</p>]]></content>
    
    
    <categories>
      
      <category>集合框架</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
