<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="zsfblues"><meta name="renderer" content="webkit"><meta name="copyright" content="zsfblues"><meta name="keywords" content="zsfblues' blog"><meta name="description" content="IT,互联网"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>ConcurrentLinkedQueue源码分析 · zsfblues' blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/me.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><meta name="generator" content="Hexo 4.2.0"></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/me.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">zsfblues</div><div class="profile-signature">zsfblues' blog</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">zsfblues' blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">ConcurrentLinkedQueue源码分析</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2016/06/15</span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="集合框架"> 集合框架</a></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><p>ConcurrentLinkedQueue作为Doug Lea在JDK5.0推出的又一个并发容器，使用的是基于FIFO的队列结构，在队尾入队，在队首出队，但使用的基于CAS的”wait-free”进行的，也就是线程竞争锁失败后不会挂起，这在一定程度使得线程的等待时间减少，但CAS并不是一个算法，它是一个CPU直接支持的硬件指令，这也就在一定程度上决定了它的平台相关性<br>当前常用的多线程同步机制可以分为下面三种类型：</p>
<blockquote>
<ol>
<li>volatile 变量：轻量级多线程同步机制，不会引起上下文切换和线程调度。仅提供内存可见性保证，不提供原子性。</li>
<li>CAS 原子指令：轻量级多线程同步机制，不会引起上下文切换和线程调度。它同时提供内存可见性和原子化更新保证。</li>
<li>互斥锁：重量级多线程同步机制，可能会引起上下文切换和线程调度，它同时提供内存可见性和原子性。<br>注：上下文切换就是CPU在不同线程中分配时间片，在不同线程任务中切换</li>
</ol>
</blockquote>
<p>ConcurrentLinkedQueue 的非阻塞算法实现主要可概括为下面几点：</p>
<ol>
<li>使用 CAS 原子指令来处理对数据的并发访问，这是非阻塞算法得以实现的基础。</li>
<li>head/tail 并非总是指向队列的头 / 尾节点，也就是说允许队列处于不一致状态。 这个特性把入队 / 出队时，原本需要一起原子化执行的两个步骤分离开来，从而缩小了入队 / 出队时需要原子化更新值的范围到唯一变量。这是非阻塞算法得以实现的关键。</li>
<li>以批处理方式来更新head/tail，从整体上减少入队 / 出队操作的开销。</li>
</ol>
<p>在ConcurrentLinkedQueue的源码中，有一段红字规定了的一些基本不变性条件</p>
<blockquote>
<ol>
<li>在入队时最后一个结点中的next域为null</li>
<li>队列中的所有未删除结点的item域不能为null且从head都可以在O(N)时间内遍历到</li>
<li>对于要删除的结点，不是将其引用直接置为空，而是将其的item域先置为null(迭代器在遍历是会跳过item为null的结点)</li>
<li>允许head和tail滞后更新，也就是上文提到的head/tail并非总是指向队列的头 / 尾节点（这主要是为了减少CAS指令执行的次数，但同时会增加volatile读的次数，但是这种消耗较小）。具体而言就是，当在队列中插入一个元素是，会检测tail和最后一个结点之间的距离是否在两个结点及以上(内部称之为hop)；而在出队时，对head的检测就是与队列的第一个结点的距离是否达到两个，有则将head指向第一个结点并将head原来指向的结点的next域指向自己，这样就能断开与队列的联系从而帮助GC</li>
</ol>
</blockquote>
<p><strong>head的不变性和可变性条件</strong></p>
<blockquote>
<p>不变性：</p>
<ol>
<li>所有未删除节点，都能从head通过调用succ()方法遍历可达。</li>
<li>head不能为null。</li>
<li>head节点的next域不能引用到自身。</li>
</ol>
<p>可变性：</p>
<ol>
<li>head节点的item域可能为null，也可能不为null。</li>
<li>允许tail滞后（lag behind）于head，也就是说：从head开始遍历队列，不一定能到达tail。</li>
</ol>
</blockquote>
<p><strong>tail的不变性和可变性条件</strong></p>
<blockquote>
<p>不变性：</p>
<ol>
<li>通过tail调用succ()方法，最后节点总是可达的。</li>
<li>tail不能为null。</li>
</ol>
<p>可变性：</p>
<ol>
<li>tail节点的item域可能为null，也可能不为 null。</li>
<li>允许tail滞后于head，也就是说：从head开始遍历队列，不一定能到达tail。</li>
<li>tail节点的next域可以引用到自身。</li>
</ol>
</blockquote>
<p><strong>初始化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">()</span></span>&#123;    <span class="comment">//将head和tail的item和next域置为null    head = tail = new Node&lt;E&gt;(null);&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>入队操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     checkNotNull(e);</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">     <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;)   <span class="comment">//1</span></span><br><span class="line">     &#123;</span><br><span class="line">         Node&lt;E&gt; q = p.next;</span><br><span class="line">         <span class="keyword">if</span> (q == <span class="keyword">null</span>)				<span class="comment">//2</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) <span class="comment">//3</span></span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">if</span> (p != t)		<span class="comment">//4</span></span><br><span class="line">                     casTail(t, newNode);	</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (p == q)	<span class="comment">//5</span></span><br><span class="line">             p = (t != (t = tail)) ? t : head; </span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             p = (p != t &amp;&amp; t != (t = tail)) ? t : q;<span class="comment">//6</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>1：对于入队操作，采用失败即重试的方式，直到入队成功 </p>
<p>2：表明p是最后一个结点 </p>
<p>3：采用CAS指令修改队列的最后一个结点的next域，从而保证最后一个结点是新插入的结点，同时将p指向这个新结点 </p>
<p>4：如果插入结点后tail和p距离达到两个结点，则修改tail的指向(失败也没关系)，这里在判断tail为最后一个结点后仍然要判断hop是否达到2主要是为了预防在并发修改下，多个线程同时修改的问题 </p>
<p>5：根据tail的可变性条件和滞后更新策略，我们知道tail的next域可以引用到自身，在ConcurrentLinkedQueue规定如果tail的next如果指向自己的话，则表明tail现在所在指向的结点已被删除(从head遍历无法到达tail)，那么就要从head开始遍历到所有的未删除结点(这也是上文head的不变性条件保证的)具体看下图：</p>
<p><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/ConcurrentLinkedQueueOffer.png" alt=""></p>
<pre><code>当然，我们还是要判断其他线程是否已经提前修改tail的指向，修改的话就表明tail结点已经更新完毕，没有引用到自身了，就可以直接重新尝试插入了。其实从这我们大致可以揣摩出作者的设计的巧妙部分：即虽然tail有滞后更新策略从而导致无法一次就将结点插入，但结点要想插入的话还是必须要当tail为最后一个结点才行 6：tail未指向尾结点，同时也没有滞后head，就像下图这样： 插入前：</code></pre><p><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/ConcurrentLinkedQueueOffer1.png" alt=""></p>
<p>这时候表明tail结点还未更新，但需要事先判断其他线程是否可能抢先插入了一个结点，如下图： 其它线程抢先插入后：</p>
<p><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/ConcurrentLinkedQueueOffer2.png" alt=""></p>
<p>在这种情况下如果插入元素的话导致tail和最后一个结点的距离达到两个,就要更新tail的指向(不得不承认这句代码的简洁性，但还是要吐槽一下，从可读性的角度和JDK6.0的版本比起来实在是难以理解)，并且tail已经指向尾结点，说明下一个结点可以直接将tail赋给p以便重新尝试插入。<br>其实仔细分析的话就可以明白多个if判断表明tail的三种可能状态：</p>
<blockquote>
<ol>
<li>tail滞后于 head。</li>
<li>tail指向尾结点。</li>
<li>tail指向非尾结点。</li>
</ol>
</blockquote>
<p><strong>出队操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      restartFromHead:</span><br><span class="line">      <span class="keyword">for</span> (;;) </span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) </span><br><span class="line">          &#123;</span><br><span class="line">              E item = p.item;</span><br><span class="line">              <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) 	<span class="comment">//1</span></span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">if</span> (p != h)		<span class="comment">//2</span></span><br><span class="line">                      updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                  <span class="keyword">return</span> item;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) <span class="comment">//3</span></span><br><span class="line">              &#123;</span><br><span class="line">                  updateHead(h, p);</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (p == q)	<span class="comment">//4</span></span><br><span class="line">                  <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">              <span class="keyword">else</span>	<span class="comment">//5</span></span><br><span class="line">                  p = q;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>1：在获取head结点后，如果item不为null的话将其设为null实现删除头结点(这是一个特殊的删除策略，即item为null的结点就是已经删除的结点，即使它还在队列中）</p>
<p><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/ConcurrentLinkedQueuePoll1.png" alt=""></p>
<p>2：删除该结点后检查head是否与头结点相差两个结点，有则向后推进一个item非null结点来更新head <img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/ConcurrentLinkedQueuePoll2.png" alt=" "></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateHead</span><span class="params">(Node&lt;E&gt; h, Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 如果两个结点不相同，尝试用CAS指令原子更新head指向新头节点</span></span><br><span class="line">     <span class="keyword">if</span> (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">     	 <span class="comment">//将旧的头结点指向自身以实现删除</span></span><br><span class="line">	 h.lazySetNext(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3：head的item为null则向后选取一个结点，如果item为null的结点，设置head指向p节点（此时队列没有元素，只有一个伪结点p） 4：结点出队失败，重新进行出队(关于p == q的判断条件我是在有点难以理解，在此只能作一个不负责任的猜测：就是上一次判断先执行了步骤5，使得p和q指向同一个item不为null的结点，在下一次循环开始前其它线程线程先删除了该结点导致步骤4的发生，这样的话就要重新获取head进行删除) A线程执行步骤5后(为了方便没有画出tail，<strong>再次声明，只是个人观点</strong>)： <a href="http://7xti77.com1.z0.glb.clouddn.com/ConcurrentLinkedQueuePoll3.png" target="_blank" rel="noopener"><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/ConcurrentLinkedQueuePoll3.png" alt="img"></a> </p>
<p>B线程抢先删除结点后A线程执行步骤4：<br><a href="http://7xti77.com1.z0.glb.clouddn.com/ConcurrentLinkedQueuePoll4.png" target="_blank" rel="noopener"><img src="http://zsfblues.oss-cn-hangzhou.aliyuncs.com/blog/ConcurrentLinkedQueuePoll4.png" alt="img"></a><br>5：在结点出队失败后可以保证下次尝试出队时p不为空(之前q = p.next ！= null才有可能跳到这一步)</p>
<p>根据head的不变性和可变性条件，在执行出队操作前，head在队列中的位置共有两种可能：</p>
<blockquote>
<ol>
<li>head指向有效结点(从head向后遍历可达的结点当中，item域不为null的结点)</li>
<li>head指向无效结点(从head向后遍历可达的结点当中，item域为null的结点)</li>
</ol>
</blockquote>
<p><strong>队列判空</strong><br>有些人在判断队列是否为空时喜欢用</p>
<blockquote>
<p>queue.size()==0</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="keyword">null</span>; p = succ(p))</span><br><span class="line">         <span class="keyword">if</span> (p.item != <span class="keyword">null</span>)</span><br><span class="line">             <span class="comment">// Collection.size() spec says to max out</span></span><br><span class="line">             <span class="keyword">if</span> (++count == Integer.MAX_VALUE)</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">return</span> count;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在计算队列的长度是并没有向我们往常一样直接通过一个变量来存储，这样主要是要尽可能保证队列在并发访问下的数据的正确性，但由于遍历时还是会有其它线程对队列的状态进行修改，因而数据仍有可能错误(removeAll,retainAll,containsAll,equals,toArray也有一样的问题)<br>可以看到这样在队列在结点较多时会依次遍历所有结点，这样的性能会有较大影响，因而可以考虑empty函数，它只要判断第一个结点(注意不一定是head指向的结点)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first() == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>最后</strong><br>ConcurrentLinkedQueue的迭代器是弱一致性的，这在并发容器中是比较普遍的现象，主要是指在一个线程在遍历队列结点而另一个线程尝试对某个队列结点进行修改的话不会抛出ConcurrentModificationException，这也就造成在遍历某个尚未被修改的结点时，在next方法返回时可以看到该结点的修改，但在遍历后再对该结点修改时就看不到这种变化。特别注意的是ConcurrentLinkedQueue提供的线程安全操作只是相对安全的，即只对单个函数调用所涉及的操作提供安全性</p>
<hr>
<p><strong>参考资料</strong></p>
<ul>
<li><p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-concurrent/index.html" target="_blank" rel="noopener">非阻塞算法在并发容器中的实现</a></p>
</li>
<li><p><a href="http://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf" target="_blank" rel="noopener">ConcurrentLinkedQueue实现的算法理论基础</a></p>
</li>
</ul>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://zsfblues.github.io">zsfblues</a></p><p> <span>Link:  </span><a href="http://zsfblues.github.io/2016/06/15/ConcurrentLinkedQueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">http://zsfblues.github.io/2016/06/15/ConcurrentLinkedQueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/3.0" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2016/06/16/%E4%BC%98%E7%A7%80%E5%8D%9A%E5%AE%A2%E9%93%BE%E6%8E%A5%E6%B1%87%E6%80%BB-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/" title="优秀博客链接汇总(长期更新)"><span>< PreviousPost</span><br><span class="prevTitle">优秀博客链接汇总(长期更新)</span></a><a class="nextSlogan" href="/2016/05/23/%E5%85%B3%E4%BA%8E%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%87%A0%E7%82%B9%E7%90%86%E8%A7%A3/" title="关于红黑树学习的几点理解"><span>NextPost ></span><br><span class="nextTitle">关于红黑树学习的几点理解</span></a><div class="clear"></div></div><div id="comment"><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: 'ConcurrentLinkedQueue源码分析',
  owner: '9928627',
  repo: 'zsfblues.github.io',
  oauth: {
    client_id: '27ef90191eda06aadd5b',
    client_secret: 'f2ed675c18da0938f480e4eef3cf44d480f6d801',
  },
})
gitment.render('container')</script></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo" target="_blank" rel="noopener"><span>Cxo</span></a></p></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>