<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="zsfblues"><meta name="renderer" content="webkit"><meta name="copyright" content="zsfblues"><meta name="keywords" content="zsfblues' blog"><meta name="description" content="IT,互联网"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>ThreadPoolExecutor的原理和设计思想 · zsfblues' blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/me.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><meta name="generator" content="Hexo 4.2.0"></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/me.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">zsfblues</div><div class="profile-signature">zsfblues' blog</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">zsfblues' blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">ThreadPoolExecutor的原理和设计思想</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2016/07/20</span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="线程池"> 线程池</a></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><p>在多线程编程十分普遍的今天，很多人都在用多线程来尽量榨干CPU的性能。但常规地为每个任务创建线程却有以下不足:</p>
<blockquote>
<ol>
<li>创建线程的消耗较高：线程作为CPU分配时间片的基本单位，较多的线程可能会引起CPU频繁地在不同的线程中切换，以至于CPU没有过多的精力来处理任务</li>
<li>资源消耗大：每创建一个线程的话就会消耗一定的内存资源，当线程数量较大时，CPU就没有过多的精力来处理每一个线程任务，导致线程空占资源，同时给JVM回收线程资源带来较大的压力</li>
<li>平台相关性：仔细观察源码的话就会发现Java中的Thread类的很多方法都是native的，这表明很多实现都是调用底层的操作系统函数来实现。这让许多的参数，包括JVM参数，栈速配占用的空间大小都受到了平台的线程，如果放到不同平台下可能会导致OOM或栈溢出等问题</li>
</ol>
</blockquote>
<hr>
<h2 id="初识Executor"><a href="#初识Executor" class="headerlink" title="初识Executor"></a>初识Executor</h2><p>既然线程的创建有这么多不足，Java的设计者就想到了通过一种统一的机制来管理线程，包括其创建，执行和销毁(这和数据库连接池的设计思想类似)，这就是Executor框架下的Executors类。它提供了4种线程池类：</p>
<ol>
<li><p>ExecutorService newFixedThreadPool(int nThreads):固定大小线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                     <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ExecutorService newSingleThreadExecutor()：包含单线程的线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ExecutorService newCachedThreadPool()：带缓存的无界线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>具体来说是当空闲线程数量大于核心线程数量(也叫基本线程数量)，该线程池会根据keepAliveTime时间(在此设定为60秒)来决定是否终止多出来的空闲线程，当然如果在这段时间类又有新任务要执行的话就会让这些空闲线程继续执行新任务。</p>
<p>当然还有一种newScheduledThreadPool线程池，它是一种支持定时或延时执行的计划类线程池，不过它的底层不是基于ThreadPoolExecutor而是ScheduledThreadPoolExecutor(ThreadPoolExecutor子类)来实现<a href="http://www.liuinsect.com/2014/11/17/scheduledthreadpoolexecutor/" target="_blank" rel="noopener">深度解析Java8 – ScheduledThreadPoolExecutor源码解析</a></p>
<hr>
<p>上述几种线程池都是由Executors的工厂方法返回的，在很多书上都有介绍它们的基本使用，仔细观察会发现它们都是基于ThreadPoolExecutor实现的，在其JDK文档中这样描述：“ <strong>为了便于跨大量上下文使用，此类提供了很多可调整的参数和扩展钩子 (hook)。但是，强烈建议程序员使用较为方便的 Executors 工厂方法 Executors.newCachedThreadPool()（无界线程池，可以进行自动线程回收）、Executors.newFixedThreadPool(int)（固定大小线程池）和 Executors.newSingleThreadExecutor()（单个后台线程），它们均为大多数使用场景预定义了设置。否则，在手动配置和调整此类时</strong>” 可以看到ThreadPoolExecutor是线程池底层的真正实现，而之前的那几种线程池只是对其做的一层简单封装，其作用在于帮用户预先设置好了某些参数。ThreadPoolExecutor则允许用户更加灵活的配置线程池，包括核心和最大线程数，保持活动时间，如何实现缓存队列，相应的饱和策略，如何配置线程工厂以及对ThreadPoolExecutor的扩展(主要通过重写beforeExecute，afterExecute和terminated方法)</p>
<hr>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="ctl"><a href="#ctl" class="headerlink" title="ctl"></a>ctl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>这个变量是整个类的核心，AtomicInteger保证了对这个变量的操作是原子的，ThreadPoolExecutor用这一个变量保存了两个内容：</p>
<ul>
<li>所有工作线程的数量</li>
<li>各个线程的状态（runState）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line">   <span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">   <span class="comment">// Packing and unpacking ctl</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<p>从上面我们可以看到设计者将int变量的低29位存线程数(大约5亿个)，高3位存runState,这样runState有5个值</p>
<ul>
<li>RUNNING:接收新的任务，并处理队列中的任务</li>
<li>SHUTDOWN:不接收新的任务，并处理队列中的任务</li>
<li>STOP:不接收新的任务，不处理队列中的任务并尝试中断正在执行的任务</li>
<li>TIDYING：所有任务已终止，工作线程数为0</li>
<li>TERMINATED：terminated()方法执行完</li>
</ul>
<p>其中runStateOf函数用于获取runState的值，上文提到ctl存了线程状态和工作线程数量值，也就是函数中传过来的参数c，CAPACITY的值是<br>00011111111111111111111111111111，取反后为11100000000000000000000000000000，然后进行求与运算取c的值高三位，也就是runState值。<br>对于workerCountOf函数，则是取c的低29位值，也就是workerCount<br>对于ctlOf函数，则是将参数rs(runState)和wc(workerCount)组合成ctl值，也就是说前面两个是从ctl值分离出两个值，这个则是合并</p>
<p>接下来我们看一下ThreadPoolExecutor提供了哪些参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                             TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                             RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<p>corePoolSize：基本线程数，当线程池没有任务需要处理时能保持的最大空闲线程数<br>maximumPoolSize：线城池的最大线程数，当缓存队列满了后如果当前线程数小于此值就创建新的线程来处理任务<br>keepAliveTime：当线程池中的空闲线程数大于corePoolSize时多出来的线程所允许的最大存活时间，后面的TimeUnit指明时间单位<br>BlockingQueue：用于存放已提交任务的一种缓存队列<br>ThreadFactory：用来创建线程的工厂<br>RejectedExecutionHandler：当缓存队列满了且无法再创建新线程时所要采取的饱和策略</p>
<p><strong>关于缓存队列的实现策略，有以下三种</strong></p>
<ol>
<li>同步提交。缓存队列的默认选项是SynchronousQueue，这种实现策略主要是当要往队列中提交任务时，必须要有一个线程在等待任务执行，当没有线程来接收任务就创建一个线程，通常要求maximumPoolSizes无限大以避免拒绝新提交的任务。另外这种实现策略可以有效避免任务在队列中进行等待，当然你也可以理解为资源数为1，消费者有无数个的消费者-生产者模型，它的主要实现就是之前的newCachedThreadPool</li>
<li>无界队列。其默认实现就是LinkedBlockingQueue，之前的newSingleThreadExecutor和newFixedThreadPool都是基于此策略来实现缓存队列。这种无界队列在任务提交较为迅速时能避免创建线程，但队列的持续性快速增长仍会带来性能下降的问题，最终只能抑制任务提交以免耗尽内存</li>
<li>有界队列。可以基于ArrayBlockingQueue实现。基于这种策略的实现往往需要我们在线程数和缓存队列长度中找到一个平衡点，因为队列的有界性，当超出队列长度时只能通过创建新的线程来处理提交的任务，但无限创建线程会耗尽内存，但是通过扩大队列的长度又会导致执行任务的线程数太少，降低系统的吞吐量</li>
</ol>
<h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">       <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">           <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           c = ctl.get();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">           <span class="comment">//任务提交到队列后为防止线程池状态突变，进行双重检查</span></span><br><span class="line">           <span class="comment">//如果线程池处在非运行下，就要及时移出刚刚入队的任务</span></span><br><span class="line">           <span class="comment">//并采取饱和策略</span></span><br><span class="line">           <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">           <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">               reject(command);</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">           	<span class="comment">//这行代码是为了SHUTDOWN状态下没有活动线程了，但是队列里还有任务没执行这种特殊情况。</span></span><br><span class="line">               addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">           reject(command);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>此方法用于提交要执行的任务，它主要经历了以下3个步骤：</p>
<ol>
<li>如果当前线程数小于corePoolSize数，就直接创建一个线程来执行此任务而不是将其放到缓存队列中</li>
<li>如果当前线程数大于等于corePoolSize数，当前线程处于运行状态，就尝试将任务放到缓存队列中</li>
<li>缓存队列满了并且当前线程数不大于maximumPoolSize就创建新的线程来执行任务，否则采取相应的饱和策略来处理</li>
</ol>
<p>其中的addWorker难以理解，遂借用别人的理解(o(╯□╰)o)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">        retry: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);<span class="comment">// 当前线程池状态</span></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="comment">// 这条语句等价：rs &gt;= SHUTDOWN &amp;&amp; (rs != SHUTDOWN || firstTask != null ||</span></span><br><span class="line">            <span class="comment">// workQueue.isEmpty())</span></span><br><span class="line">            <span class="comment">// 满足下列调价则直接返回false，线程创建失败:</span></span><br><span class="line">            <span class="comment">// rs &gt; SHUTDOWN:STOP || TIDYING || TERMINATED 此时不再接受新的任务，且所有任务执行结束</span></span><br><span class="line">            <span class="comment">// rs = SHUTDOWN:firtTask != null 此时不再接受任务，但是仍然会执行队列中的任务</span></span><br><span class="line">            <span class="comment">// rs = SHUTDOWN:firtTask == null见execute方法的addWorker(null,</span></span><br><span class="line">            <span class="comment">// false)，任务为null &amp;&amp; 队列为空</span></span><br><span class="line">            <span class="comment">// 最后一种情况也就是说SHUTDONW状态下，如果队列不为空还得接着往下执行，为什么？add一个null任务目的到底是什么？</span></span><br><span class="line">            <span class="comment">// 看execute方法只有workCount==0的时候firstTask才会为null结合这里的条件就是线程池SHUTDOWN了不再接受新任务</span></span><br><span class="line">            <span class="comment">// 但是此时队列不为空，那么还得创建线程把任务给执行完才行。</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span> &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 走到这的情形：</span></span><br><span class="line">            <span class="comment">// 1.线程池状态为RUNNING</span></span><br><span class="line">            <span class="comment">// 2.SHUTDOWN状态，但队列中还有任务需要执行</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))<span class="comment">// 原子操作递增workCount</span></span><br><span class="line">                    <span class="keyword">break</span> retry;<span class="comment">// 操作成功跳出的重试的循环</span></span><br><span class="line">                c = ctl.get(); <span class="comment">// Re-read ctl</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)<span class="comment">// 如果线程池的状态发生变化则重试</span></span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// wokerCount递增成功</span></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 并发的访问线程池workers对象必须加锁</span></span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                    <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">                    <span class="comment">// RUNNING状态 || SHUTDONW状态下清理队列中剩余的任务</span></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                        <span class="comment">// 将新启动的线程添加到线程池中</span></span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="comment">// 更新largestPoolSize</span></span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 启动新添加的线程，这个线程首先执行firstTask，然后不停的从队列中取任务执行</span></span><br><span class="line">                <span class="comment">// 当等待keepAlieTime还没有任务执行则该线程结束。见runWoker和getTask方法的代码。</span></span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    t.start();<span class="comment">// 最终执行的是ThreadPoolExecutor的runWoker方法</span></span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 线程启动失败，则从wokers中移除w并递减wokerCount</span></span><br><span class="line">            <span class="keyword">if</span> (!workerStarted)</span><br><span class="line">                <span class="comment">// 递减wokerCount会触发tryTerminate方法</span></span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="shutdown和shutdownNow"><a href="#shutdown和shutdownNow" class="headerlink" title="shutdown和shutdownNow"></a>shutdown和shutdownNow</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">      mainLock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//检查调用者是否具有关闭和中断工作线程权限</span></span><br><span class="line">          checkShutdownAccess();</span><br><span class="line">          <span class="comment">//将线程池状态设为shutdown</span></span><br><span class="line">          advanceRunState(SHUTDOWN);</span><br><span class="line">          <span class="comment">//中断空闲线程</span></span><br><span class="line">          interruptIdleWorkers();</span><br><span class="line">          onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          mainLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      tryTerminate();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>shutdown方法主要是为了阻止任务提交到缓存队列中，但对已提交的任务还是会执行，但是不保证一定执行完，如果有需求的话，可以考虑调用awaitTermination完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      List&lt;Runnable&gt; tasks;</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">      mainLock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          checkShutdownAccess();</span><br><span class="line">          <span class="comment">//和shutdown不同，它将线程池状态置为stop</span></span><br><span class="line">          advanceRunState(STOP);</span><br><span class="line">          <span class="comment">//终止所有线程(包括空闲线程和工作线程)</span></span><br><span class="line">          interruptWorkers();</span><br><span class="line">          <span class="comment">//返回队列中还没有被执行的任务</span></span><br><span class="line">          tasks = drainQueue();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          mainLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      tryTerminate();</span><br><span class="line">      <span class="keyword">return</span> tasks;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>尝试停止所有的活动执行任务、暂停等待任务的处理，并返回等待执行的任务列表。在从此方法返回的任务队列中排空（移除）这些任务。</p>
<h3 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h3><p>默认的线程工厂实现智能创建一个新的非守护线程，并且不包含任何的配置信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;  <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;&#125;</span><br></pre></td></tr></table></figure>

<p>将要执行的任务封装到一个线程中执行，我们可以通过实现这个接口扩展线程工厂的行为，添加我们想要改变的信息，比如线程名字，优先级之类的</p>
<h3 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h3><p>之前曾经谈到的，如果在缓存队列已满并且无法创建新的线程来执行新的线程就会启用相应的饱和策略</p>
<blockquote>
<ol>
<li>AbortPolicy：处理程序遭到拒绝将抛出运行时 RejectedExecutionException，也是默认的饱和策略</li>
<li>DiscardPolicy：不能执行的任务将被删除</li>
<li>DiscardOldestPolicy：如果执行程序尚未关闭，则位于缓存队列头部的任务将被删除，然后重新执行程序（如果再次失败，则重复此过程）</li>
<li>CallerRunsPolicy：拒绝新任务的提交，但会在调用execute方法的线程中执行，除非当前线程池关闭，能够减缓新任务的提交速度</li>
</ol>
</blockquote>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的讲解，大概可以了解到线程池的一些设计思想，这和数据库连接池的设计有异曲同工的地方。当然，这不是一篇源码分析的文章，没有面面俱到。大致来说线程池的设计思想可以归为以下几点：</p>
<ul>
<li>通过corePoolSize来控制工作线程数，以免一开始就创建较多线程来执行，这种思想有点像tcp协议中用慢开始方法进行拥塞控制</li>
<li>用一个缓存队列将提交的任务进行保存，让有限的线程来得及处理任务</li>
<li>相应的饱和策略，这种策略可以在无法继续执行任务时提供一种合理的应对措施</li>
<li>此外灵活的线程工厂可以让用户定制新线程的行为</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>&lt;&lt;Java并发编程实战&gt;&gt;</li>
<li><a href="http://www.cnblogs.com/zhanjindong/p/java-concurrent-package-ThreadPoolExecutor.html" target="_blank" rel="noopener">Java并发包源码学习之线程池（一）ThreadPoolExecutor源码分析</a></li>
</ol>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://zsfblues.github.io">zsfblues</a></p><p> <span>Link:  </span><a href="http://zsfblues.github.io/2016/07/20/ThreadPoolExecutor%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/">http://zsfblues.github.io/2016/07/20/ThreadPoolExecutor%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/3.0" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2016/09/03/%E6%9C%89%E5%BA%8F%E7%9A%84HashMap-LinkedHashMap/" title="有序的HashMap-LinkedHashMap"><span>< PreviousPost</span><br><span class="prevTitle">有序的HashMap-LinkedHashMap</span></a><a class="nextSlogan" href="/2016/06/16/%E4%BC%98%E7%A7%80%E5%8D%9A%E5%AE%A2%E9%93%BE%E6%8E%A5%E6%B1%87%E6%80%BB-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/" title="优秀博客链接汇总(长期更新)"><span>NextPost ></span><br><span class="nextTitle">优秀博客链接汇总(长期更新)</span></a><div class="clear"></div></div><div id="comment"><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: 'ThreadPoolExecutor的原理和设计思想',
  owner: '9928627',
  repo: 'zsfblues.github.io',
  oauth: {
    client_id: '27ef90191eda06aadd5b',
    client_secret: 'f2ed675c18da0938f480e4eef3cf44d480f6d801',
  },
})
gitment.render('container')</script></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo" target="_blank" rel="noopener"><span>Cxo</span></a></p></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#初识Executor"><span class="toc-number">1.</span> <span class="toc-text">初识Executor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor"><span class="toc-number">2.</span> <span class="toc-text">ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ctl"><span class="toc-number">2.1.</span> <span class="toc-text">ctl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行"><span class="toc-number">2.2.</span> <span class="toc-text">执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shutdown和shutdownNow"><span class="toc-number">2.3.</span> <span class="toc-text">shutdown和shutdownNow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程工厂"><span class="toc-number">2.4.</span> <span class="toc-text">线程工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#饱和策略"><span class="toc-number">2.5.</span> <span class="toc-text">饱和策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文献"><span class="toc-number">4.</span> <span class="toc-text">参考文献</span></a></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>